<!DOCTYPE html>
<html class="dark" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes" name="viewport"/>
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Tower Defense Game</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;700&amp;display=swap" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<script id="tailwind-config">
    tailwind.config = {
      darkMode: "class",
      theme: {
        extend: {
          colors: {
            "primary": "#17cf17",
            "background-light": "#f6f8f6",
            "background-dark": "#112111",
          },
          fontFamily: {
            "display": ["Space Grotesk"]
          },
          borderRadius: {
            "DEFAULT": "0.25rem",
            "lg": "0.5rem",
            "xl": "0.75rem",
            "full": "9999px"
          },
        },
      },
    }
</script>
<style>
    .material-symbols-outlined {
      font-variation-settings:
        'FILL' 0,
        'wght' 400,
        'GRAD' 0,
        'opsz' 24
    }
    body {
      min-height: max(884px, 100dvh);
    }
    .screen { 
      display: none; 
      min-height: 100vh;
      height: 100vh;
      overflow-y: auto;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      z-index: 100;
      background-color: inherit;
    }
    /* Crop tower images to remove text areas */
    .tower-icon-crop {
      object-fit: cover;
      object-position: center top;
      clip-path: inset(0 0 30% 0); /* Crop bottom 30% where text usually appears */
    }
    .tower-icon-crop-large {
      object-fit: cover;
      object-position: center top;
      clip-path: inset(0 0 25% 0); /* Crop bottom 25% for larger icons */
    }
    .screen.active { 
      display: flex !important; 
      flex-direction: column; 
    }
    
    /* Ensure non-active screens are completely hidden */
    .screen:not(.active) {
      display: none !important;
      visibility: hidden;
    }
    
    /* Ensure upgrade panel can receive clicks and is above canvas */
    #upgradePanel {
      pointer-events: auto !important;
      z-index: 1000 !important;
    }
    
    #upgradePanel button {
      pointer-events: auto !important;
      cursor: pointer !important;
    }
    .tower-option.selected {
      transform: scale(1.1);
      border: 2px solid #17cf17;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    /* Allow clicks to pass through footer background to canvas, but keep buttons interactive */
    #inGame footer {
      pointer-events: none;
      z-index: 10;
    }
    /* Make all direct children of footer clickable (buttons, tower options) */
    #inGame footer > * {
      pointer-events: auto;
    }
    /* Ensure canvas is always clickable */
    #gameCanvas {
      pointer-events: auto !important;
      position: relative;
      z-index: 1;
      touch-action: none; /* Prevent default touch behaviors */
    }
    
    /* Mobile Optimizations */
    @media (max-width: 768px) {
      /* Touch-friendly button sizes - minimum 44px */
      button, .cursor-pointer {
        min-height: 44px;
        min-width: 44px;
      }
      
      /* Larger text on mobile */
      body {
        font-size: 16px; /* Prevent iOS zoom on input focus */
      }
      
      /* Better spacing for mobile */
      .screen {
        padding-bottom: env(safe-area-inset-bottom, 0);
      }
      
      /* Responsive canvas container */
      #inGame main {
        position: relative;
        width: 100%;
        height: calc(100vh - 200px); /* Account for header/footer */
        min-height: 300px;
      }
      
      #gameCanvas {
        width: 100% !important;
        height: 100% !important;
        object-fit: contain;
      }
      
      /* Tower selection footer - better scrolling on mobile */
      #inGame footer {
        padding-bottom: env(safe-area-inset-bottom, 16px);
      }
      
      #inGame footer .flex {
        gap: 12px;
        padding: 0 8px;
      }
      
      .tower-option {
        min-width: 100px !important;
        padding: 8px;
      }
      
      /* Smaller header on mobile */
      header {
        padding: 12px 16px !important;
      }
      
      /* Better button spacing */
      .flex.flex-col.gap-3 button {
        margin-bottom: 8px;
      }
      
      /* Level selection cards - stack on mobile */
      .flex.flex-wrap.gap-4 > div {
        min-width: calc(50% - 8px);
      }
      
      /* Shop grid - 1 column on very small screens */
      .grid.grid-cols-2 {
        grid-template-columns: 1fr;
      }
      
      /* Tower ability buttons - reposition for mobile */
      #towerAbilitiesPanel {
        top: auto;
        bottom: 120px;
        right: 8px;
        transform: none;
        flex-direction: row;
        gap: 8px;
      }
      
      #towerAbilitiesPanel button {
        width: 48px;
        height: 48px;
      }
      
      /* Upgrade panel - full width on mobile */
      #upgradePanel {
        width: calc(100% - 32px) !important;
        max-width: 100% !important;
        left: 16px !important;
        right: 16px !important;
      }
      
      /* Main menu buttons - better spacing */
      .flex.flex-1.gap-3.max-w-\[480px\] {
        max-width: 100%;
        padding: 0 16px;
      }
      
      /* Bottom menu icons - better touch targets */
      .grid.grid-cols-\[repeat\(auto-fit\2c minmax\(80px\2c _1fr\)\)\] > div {
        min-width: 70px;
        padding: 12px 8px;
      }
      
      /* Prevent text selection on buttons during touch */
      button, .cursor-pointer {
        -webkit-tap-highlight-color: rgba(23, 207, 23, 0.3);
        -webkit-touch-callout: none;
        user-select: none;
      }
      
      /* Better font sizes for mobile */
      h1 { font-size: 1.75rem; }
      h2 { font-size: 1.5rem; }
      h3 { font-size: 1.25rem; }
      
      /* Level cards - better aspect ratio on mobile */
      .aspect-\[4\/5\] {
        aspect-ratio: 3/4;
      }
    }
    
    /* Very small screens (phones in portrait) */
    @media (max-width: 480px) {
      /* Even more compact spacing */
      .p-4 {
        padding: 12px;
      }
      
      /* Smaller text but still readable */
      .text-lg {
        font-size: 1rem;
      }
      
      .text-2xl {
        font-size: 1.5rem;
      }
      
      /* Tower options - smaller but still touchable */
      .tower-option {
        min-width: 85px !important;
      }
      
      /* Main menu hero image - smaller on very small screens */
      .min-h-48 {
        min-height: 120px;
      }
    }
    
    /* Landscape mobile optimization */
    @media (max-width: 896px) and (orientation: landscape) {
      #inGame main {
        height: calc(100vh - 150px);
      }
      
      #inGame footer {
        padding: 8px;
      }
      
      header {
        padding: 8px 12px !important;
      }
    }
    
    /* Prevent double-tap zoom on buttons */
    button {
      touch-action: manipulation;
    }
    
    /* Smooth scrolling for mobile */
    .screen {
      -webkit-overflow-scrolling: touch;
    }
    
    /* Better focus states for accessibility */
    button:focus-visible,
    .cursor-pointer:focus-visible {
      outline: 2px solid #17cf17;
      outline-offset: 2px;
    }
    
    /* Fix viewport height for mobile browsers with dynamic address bars */
    :root {
      --vh: 1vh;
    }
    
    @supports (height: 100dvh) {
      :root {
        --vh: 1dvh;
      }
    }
</style>
<script>
  // Fix viewport height for mobile browsers
  function setViewportHeight() {
    const vh = window.innerHeight * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  }
  
  // Set on load and resize
  setViewportHeight();
  window.addEventListener('resize', setViewportHeight);
  window.addEventListener('orientationchange', () => {
    setTimeout(setViewportHeight, 100);
  });
</script>
</head>
<body class="bg-background-light dark:bg-background-dark">
<div id="app" class="relative flex h-auto min-h-screen w-full flex-col bg-background-light dark:bg-background-dark font-display" style='font-family: "Space Grotesk", "Noto Sans", sans-serif;'>
<!-- Main Menu -->
<div id="mainMenu" class="screen active">
  <div class="flex items-center bg-background-light dark:bg-background-dark p-4 pb-2 justify-between">
    <div class="flex items-center gap-3">
      <div id="playerIcon" class="bg-center bg-no-repeat aspect-square bg-cover rounded-full size-10 cursor-pointer hover:scale-110 transition-transform border-2 border-white/30 hover:border-white/60" onclick="openPlayerProfile()" title="View Player Profile" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuCIGp3UYF8LdNpijORgAxp349l_bu9hy38_JOoJoqFzWGD3xg5ZdVYIV1x2L4942Wdbin2LLP3zomOedC70Nv93K70y9wgjvNOuJrBOG78kHgg8uwQKpZj2FCz4H0X40HNhMwCVmlgzdHVVx4pA20Z4MOrcTkiY0Aq5yi5wSYbekuDFkCSZ-r-f4-3IyRjtm6vMqtRNqmsVHJKJN2Jslr-mj4poUPQHg8UABAfUj-d2doX2dSgvs0lTPC1G6gXqxCK9Vi6gaDGk4QE");'></div>
      <div>
        <p id="playerNameDisplay" class="text-white text-base font-bold leading-normal">Player123</p>
        <p id="playerLevelDisplay" class="text-gray-400 text-sm font-normal leading-normal">Level 1</p>
        <div class="w-20 h-2 bg-gray-600 rounded-full mt-1">
          <div id="experienceBar" class="h-full bg-blue-500 rounded-full transition-all duration-300" style="width: 0%"></div>
        </div>
        <p id="experienceText" class="text-gray-500 text-xs mt-1">0/6 EXP</p>
      </div>
    </div>
    <div class="flex items-center justify-end gap-2">
      <span class="material-symbols-outlined text-yellow-400 text-2xl">monetization_on</span>
      <p id="mainMenuGoldDisplay" class="text-yellow-400 text-base font-bold leading-normal tracking-[0.015em] shrink-0">200</p>
    </div>
  </div>
  
  <div class="@container px-4">
    <div class="w-full bg-center bg-no-repeat bg-contain flex flex-col justify-end overflow-hidden min-h-48" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuDIgjRo5sPwl09ORbhNORnU8GJ2TyNGljRO97_iN65Raw5fhEcbTSPeIuQY6eH1atKkd_0CkPmEZLmdFPTDULcf-dh36naMU99b4RUE2GyQLXduWMFtaR3hVp8cHe-iEXvIFawuQthrO-r7ZbvkDiRuAdtgu_wnuEokKNdUCczQhjuqWbTdrfIXI24DMzEOpLyL-a9pLWBk86_TJqrnBOhQLopD-hKDs4a5Kjd536fZRn_vEIR0ZD5nWyrYrM1zi-QdEA5M1QE_WyM");'></div>
  </div>
  
  <div class="flex justify-center mt-4">
    <div class="flex flex-1 gap-3 max-w-[480px] flex-col items-stretch px-4 py-3">
      <button class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-14 px-5 bg-primary text-background-dark text-lg font-bold leading-normal tracking-[0.015em] w-full shadow-lg shadow-primary/30 hover:bg-primary/90 transition-transform transform hover:scale-105" onclick="goToScreen('levelSelection')">
        <span class="truncate">New Game</span>
      </button>
      <button class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-14 px-5 bg-primary/20 text-white text-lg font-bold leading-normal tracking-[0.015em] w-full hover:bg-primary/30 transition-colors" onclick="loadGame()">
        <span class="truncate">Load Game</span>
      </button>
      <button class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-14 px-5 bg-primary/20 text-white text-lg font-bold leading-normal tracking-[0.015em] w-full hover:bg-primary/30 transition-colors" onclick="goToScreen('shop')">
        <span class="truncate">Shop</span>
      </button>
      <button class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-14 px-5 bg-primary/20 text-white text-lg font-bold leading-normal tracking-[0.015em] w-full hover:bg-primary/30 transition-colors" onclick="openSettings()">
        <span class="truncate">Settings</span>
      </button>
      <button id="mainMenuResetButton" class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-lg h-14 px-5 bg-red-600/80 text-white text-lg font-bold leading-normal tracking-[0.015em] w-full hover:bg-red-600 transition-colors" onclick="resetAllProgress()" style="display: none;">
        <span class="truncate">ðŸ”„ Reset All Progress</span>
      </button>
    </div>
  </div>
  <div class="flex-grow"></div>
  
  <div class="@container mb-2">
    <div class="gap-2 px-4 grid-cols-[repeat(auto-fit,minmax(80px,_1fr))] grid">
      <div class="flex flex-col items-center gap-2 bg-background-light dark:bg-background-dark py-2.5 text-center cursor-pointer" onclick="toggleSound()">
        <div class="rounded-full bg-primary/20 p-3 hover:bg-primary/30">
          <span id="soundIcon" class="material-symbols-outlined text-white text-2xl">volume_up</span>
        </div>
        <p class="text-white text-sm font-medium leading-normal">Sound</p>
      </div>
      <div class="flex flex-col items-center gap-2 bg-background-light dark:bg-background-dark py-2.5 text-center cursor-pointer" onclick="openCommunity()">
        <div class="rounded-full bg-primary/20 p-3 hover:bg-primary/30">
          <span class="material-symbols-outlined text-white text-2xl">groups</span>
        </div>
        <p class="text-white text-sm font-medium leading-normal">Community</p>
      </div>
      <div class="flex flex-col items-center gap-2 bg-background-light dark:bg-background-dark py-2.5 text-center cursor-pointer" onclick="openQuests()">
        <div class="rounded-full bg-primary/20 p-3 hover:bg-primary/30">
          <span class="material-symbols-outlined text-white text-2xl">assignment</span>
        </div>
        <p class="text-white text-sm font-medium leading-normal">Quests</p>
      </div>
      <div class="flex flex-col items-center gap-2 bg-background-light dark:bg-background-dark py-2.5 text-center cursor-pointer" onclick="openRewards()">
        <div class="rounded-full bg-primary/20 p-3 hover:bg-primary/30">
          <span class="material-symbols-outlined text-white text-2xl">card_giftcard</span>
        </div>
        <p class="text-white text-sm font-medium leading-normal">Rewards</p>
      </div>
      <div class="flex flex-col items-center gap-2 bg-background-light dark:bg-background-dark py-2.5 text-center cursor-pointer" onclick="goToScreen('inventory')">
        <div class="rounded-full bg-primary/20 p-3 hover:bg-primary/30">
          <span class="material-symbols-outlined text-white text-2xl">backpack</span>
        </div>
        <p class="text-white text-sm font-medium leading-normal">Inventory</p>
      </div>
    </div>
  </div>
  <p class="text-primary/70 text-sm font-normal leading-normal pb-4 pt-1 px-4 text-center">Version 1.0.0</p>
</div>

<!-- Level Selection -->
<div id="levelSelection" class="screen">
  <div class="flex items-center bg-background-light dark:bg-background-dark p-4 pb-2 justify-between sticky top-0 z-10">
    <div class="text-slate-800 dark:text-white flex size-12 shrink-0 items-center justify-start cursor-pointer" onclick="goToScreen('mainMenu')">
      <span class="material-symbols-outlined text-2xl">arrow_back</span>
    </div>
    <h2 class="text-slate-900 dark:text-white text-lg font-bold leading-tight tracking-[-0.015em] flex-1 text-center">Level Select</h2>
    <div class="flex w-12 items-center justify-end"></div>
  </div>
  
  <div class="flex flex-wrap gap-4 p-4">
    <div class="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-4 bg-slate-200/50 dark:bg-white/5">
      <p class="text-slate-700 dark:text-slate-300 text-sm font-medium leading-normal">Gold</p>
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-amber-400 text-2xl">monetization_on</span>
        <p id="levelSelectionGoldDisplay" class="text-slate-900 dark:text-white tracking-light text-2xl font-bold leading-tight">500</p>
      </div>
    </div>
    <div class="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-4 bg-slate-200/50 dark:bg-white/5">
      <p class="text-slate-700 dark:text-slate-300 text-sm font-medium leading-normal">Gems</p>
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-sky-400 text-2xl">diamond</span>
        <p id="levelSelectionGemsDisplay" class="text-slate-900 dark:text-white tracking-light text-2xl font-bold leading-tight">0</p>
      </div>
    </div>
  </div>
  
  <div class="grid grid-cols-[repeat(auto-fit,minmax(158px,1fr))] gap-4 p-4">
    <div class="relative bg-cover bg-center flex flex-col rounded-xl justify-end aspect-[4/5] overflow-hidden border-2 border-primary cursor-pointer hover:scale-105 transition-all" onclick="selectLevel('woods'); document.getElementById('playButton').textContent = 'Play Whispering Woods';" style='background-image: linear-gradient(0deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0) 50%), url("https://lh3.googleusercontent.com/aida-public/AB6AXuBwqAP4klYFzwcmYkMsH4YVJs1MWN4EubgL-Jdd3t52Xg9lWqmYJ3yLTnBV7Z5F8eGldhT4_YlyvVCu59MKVyXB2IWvyg2Q-3JnNoRbh_S2Y3O8sFu7uUZkSBRu5LQUFpwUfVLjk_nA1EIED3UA1-RANqj5Tt9gdYlOkKICYgay_c4ZcwSX1cZey5xPjXDGjlNxVXyWvxGt2fDWZA8GoNlvw43xtg75hxaB8I2NMKPLaJQUmC0Xyb5ognvJRHWv866d8kmNtMOoPnE");'>
      <div class="absolute top-2 right-2 flex items-center gap-0.5 text-yellow-400">
        <span class="material-symbols-outlined text-base !text-yellow-400" style="font-variation-settings: 'FILL' 1;">star</span>
        <span class="material-symbols-outlined text-base !text-yellow-400" style="font-variation-settings: 'FILL' 1;">star</span>
        <span class="material-symbols-outlined text-base !text-yellow-400" style="font-variation-settings: 'FILL' 1;">star</span>
      </div>
      <div class="flex flex-col gap-2 p-3">
        <p class="text-white text-base font-bold leading-tight">Whispering Woods</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-sm text-red-500">skull</span>
          <div class="flex items-center gap-1 text-primary">
            <span class="material-symbols-outlined text-sm">monetization_on</span>
            <span class="material-symbols-outlined text-sm">diamond</span>
          </div>
        </div>
      </div>
    </div>
    <div class="relative bg-cover bg-center flex flex-col rounded-xl justify-end aspect-[4/5] overflow-hidden border-2 border-white/20 cursor-pointer hover:border-primary hover:scale-105 transition-all" onclick="selectLevel('frozen'); document.getElementById('playButton').textContent = 'Play Frozen Pass';" style='background-image: linear-gradient(0deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0) 50%), url("https://lh3.googleusercontent.com/aida-public/AB6AXuCtNdytjxnN29td1EC7jXk7IiDufNhXABtP_bDQOx3JRNo6ISJ89VGgcEp7gTmU_hzybitOYUC39P2DYdT6x9eqhL9XwropBtXCb6Mvii4vZWp1jIz2anKDy2Spz86sMIS-bOr96qYX5yb9oNZBQhr47Imd2d_ObxxF9USEoGsPZuSEI_71Ljz5EulIz0XyEUekNElvRTrcsE2Q1S0tdIQ8dgc2xqzLzrTkIHpPuBiAegXsfYdZIo0AO8PxqR6OQao8BO2dAkZ9EjY");'>
      <div class="absolute top-2 right-2 flex items-center gap-0.5 text-white/50">
        <span class="material-symbols-outlined text-base">lock</span>
      </div>
      <div class="flex flex-col gap-2 p-3">
        <p class="text-white text-base font-bold leading-tight">Frozen Pass</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-sm text-red-500">skull</span>
          <span class="material-symbols-outlined text-sm text-red-500">skull</span>
          <div class="flex items-center gap-1 text-primary">
            <span class="material-symbols-outlined text-sm">monetization_on</span>
            <span class="material-symbols-outlined text-sm">diamond</span>
          </div>
        </div>
        <p class="text-gray-400 text-xs">Complete Wave 20 to unlock</p>
      </div>
    </div>
    <div class="relative bg-cover bg-center flex flex-col rounded-xl justify-end aspect-[4/5] overflow-hidden border-2 border-white/20 cursor-pointer hover:border-primary hover:scale-105 transition-all" onclick="selectLevel('desert'); document.getElementById('playButton').textContent = 'Play Desert Oasis';" style='background-image: linear-gradient(0deg, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0) 50%), url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'>
      <div class="absolute top-2 right-2 flex items-center gap-0.5 text-white/50">
        <span class="material-symbols-outlined text-base">lock</span>
      </div>
      <div class="flex flex-col gap-2 p-3">
        <p class="text-white text-base font-bold leading-tight">Desert Oasis</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-sm text-red-500">skull</span>
          <span class="material-symbols-outlined text-sm text-red-500">skull</span>
          <span class="material-symbols-outlined text-sm text-red-500">skull</span>
          <div class="flex items-center gap-1 text-primary">
            <span class="material-symbols-outlined text-sm">monetization_on</span>
            <span class="material-symbols-outlined text-sm">diamond</span>
          </div>
        </div>
        <p class="text-gray-400 text-xs">Complete Frozen Pass to unlock</p>
      </div>
    </div>
  </div>
  
  <div class="flex px-4 py-3 mt-auto sticky bottom-0 z-10 bg-background-light/80 dark:bg-background-dark/80 backdrop-blur-lg">
    <button id="playButton" class="flex min-w-[84px] max-w-[480px] cursor-pointer items-center justify-center overflow-hidden rounded-xl h-14 px-5 flex-1 bg-primary text-background-dark text-lg font-bold leading-normal tracking-[0.015em] shadow-lg shadow-primary/30" onclick="startGame()">
      <span class="truncate">Choose a level to start</span>
    </button>
  </div>
</div>

<!-- In-Game -->
<div id="inGame" class="screen relative flex h-[100dvh] w-full flex-col overflow-hidden">
  <header class="absolute top-0 left-0 right-0 z-10 bg-gradient-to-b from-black/50 to-transparent p-4 pb-12">
    <!-- Countdown Timer Display -->
    <div id="countdownTimer" class="absolute top-4 left-1/2 transform -translate-x-1/2 z-20 bg-red-600/90 backdrop-blur-sm rounded-full px-6 py-2 border-2 border-red-400 shadow-lg" style="display: none;">
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-white text-xl animate-pulse">timer</span>
        <span id="countdownText" class="text-white font-bold text-xl">10</span>
      </div>
    </div>
    <div class="flex items-center justify-between gap-4">
      <div class="flex items-center gap-4">
        <div class="flex items-center gap-2 rounded-full bg-black/30 px-3 py-1.5 backdrop-blur-sm">
          <span class="material-symbols-outlined text-red-400 text-xl">favorite</span>
          <span id="livesDisplay" class="font-bold text-lg">10</span>
        </div>
        <div class="flex items-center gap-2 rounded-full bg-black/30 px-3 py-1.5 backdrop-blur-sm">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <span id="goldDisplay" class="font-bold text-lg">500</span>
        </div>
      </div>
      <div class="flex flex-col items-end gap-1">
        <h2 id="waveDisplay" class="text-white text-lg font-bold leading-tight tracking-[-0.015em]">Wave: 1/20</h2>
        <p id="killsDisplay" class="text-white text-xs font-medium">Kills: 0</p>
      </div>
      <div class="flex items-center gap-2">
        <button id="fastForwardBtn" class="flex h-10 w-10 cursor-pointer items-center justify-center overflow-hidden rounded-full bg-black/30 text-white backdrop-blur-sm hover:bg-black/50 transition-colors" onclick="toggleFastForward()" title="Fast Forward (2x Speed)">
          <span class="material-symbols-outlined">fast_forward</span>
        </button>
        <button id="pauseBtn" class="flex h-10 w-10 cursor-pointer items-center justify-center overflow-hidden rounded-full bg-black/30 text-white backdrop-blur-sm hover:bg-black/50 transition-colors" onclick="togglePause()" title="Pause/Resume">
          <span class="material-symbols-outlined">pause</span>
        </button>
        <button class="flex h-10 w-10 cursor-pointer items-center justify-center overflow-hidden rounded-full bg-black/30 text-white backdrop-blur-sm hover:bg-black/50 transition-colors" onclick="toggleInventory()" title="Tower Inventory">
          <span class="material-symbols-outlined">backpack</span>
        </button>
        <button class="flex h-10 w-10 cursor-pointer items-center justify-center overflow-hidden rounded-full bg-black/30 text-white backdrop-blur-sm hover:bg-black/50 transition-colors" onclick="saveGame()" title="Save Game">
          <span class="material-symbols-outlined">save</span>
        </button>
        <button class="flex h-10 w-10 cursor-pointer items-center justify-center overflow-hidden rounded-full bg-black/30 text-white backdrop-blur-sm hover:bg-black/50 transition-colors" onclick="goToScreen('mainMenu')" title="Exit to Menu">
          <span class="material-symbols-outlined">close</span>
        </button>
      </div>
      <!-- Auto-save indicator -->
      <div id="saveIndicator" class="absolute top-16 right-4 bg-primary/80 text-background-dark text-xs font-bold px-2 py-1 rounded opacity-0 transition-opacity duration-300 pointer-events-none">
        Auto-saved
      </div>
    </div>
  </header>
  
  <main class="flex-1 relative">
    <canvas id="gameCanvas" width="800" height="600" style="width:100%;height:100%;"></canvas>
    
    <!-- Tower Ability Buttons -->
    <div id="towerAbilitiesPanel" class="absolute top-1/2 right-4 transform -translate-y-1/2 flex flex-col gap-3 z-20">
      <!-- Archer Tower Ability Button -->
      <button id="archerAbilityBtn" class="flex flex-col items-center justify-center w-16 h-16 rounded-lg bg-primary/80 hover:bg-primary text-white backdrop-blur-sm border-2 border-primary/50 transition-all hover:scale-110 disabled:opacity-50 disabled:cursor-not-allowed" onclick="activateTowerAbility('archer')" title="Rapid Fire - 2x Attack Speed for 10s (Level 3+ Archer towers only)" style="display: none;">
        <span class="material-symbols-outlined text-2xl">bolt</span>
        <span class="text-xs font-bold mt-1">Rapid</span>
      </button>
      <!-- Cannon Tower Ability Button -->
      <button id="cannonAbilityBtn" class="flex flex-col items-center justify-center w-16 h-16 rounded-lg bg-primary/80 hover:bg-primary text-white backdrop-blur-sm border-2 border-primary/50 transition-all hover:scale-110 disabled:opacity-50 disabled:cursor-not-allowed" onclick="activateTowerAbility('cannon')" title="Extended Range - 2x Range for 10s (Level 3+ Cannon towers only)" style="display: none;">
        <span class="material-symbols-outlined text-2xl">my_location</span>
        <span class="text-xs font-bold mt-1">Range</span>
      </button>
      <!-- Fire Tower Ability Button -->
      <button id="fireAbilityBtn" class="flex flex-col items-center justify-center w-16 h-16 rounded-lg bg-primary/80 hover:bg-primary text-white backdrop-blur-sm border-2 border-primary/50 transition-all hover:scale-110 disabled:opacity-50 disabled:cursor-not-allowed" onclick="activateTowerAbility('fire')" title="Inferno - Burns all enemies for 70 damage + 15/s burn (Level 3+ Fire towers only)" style="display: none;">
        <span class="material-symbols-outlined text-2xl">local_fire_department</span>
        <span class="text-xs font-bold mt-1">Inferno</span>
      </button>
      <!-- Support Tower Wall Ability Button -->
      <button id="shieldWallAbilityBtn" class="flex flex-col items-center justify-center w-16 h-16 rounded-lg bg-primary/80 hover:bg-primary text-white backdrop-blur-sm border-2 border-primary/50 transition-all hover:scale-110 disabled:opacity-50 disabled:cursor-not-allowed" onclick="activateSupportAbility('wall')" title="Create Wall - Creates a barrier in the middle of the path for 5 seconds" style="display: none;">
        <span class="material-symbols-outlined text-2xl">wallpaper</span>
        <span class="text-xs font-bold mt-1">Wall</span>
      </button>
      <!-- Support Tower Heal Ability Button -->
      <button id="shieldHealAbilityBtn" class="flex flex-col items-center justify-center w-16 h-16 rounded-lg bg-primary/80 hover:bg-primary text-white backdrop-blur-sm border-2 border-primary/50 transition-all hover:scale-110 disabled:opacity-50 disabled:cursor-not-allowed" onclick="activateSupportAbility('heal')" title="Heal Base - Restores 1 life to your base" style="display: none;">
        <span class="material-symbols-outlined text-2xl">healing</span>
        <span class="text-xs font-bold mt-1">Heal</span>
      </button>
      <!-- Support Tower Boost Ability Button -->
      <button id="shieldBoostAbilityBtn" class="flex flex-col items-center justify-center w-16 h-16 rounded-lg bg-primary/80 hover:bg-primary text-white backdrop-blur-sm border-2 border-primary/50 transition-all hover:scale-110 disabled:opacity-50 disabled:cursor-not-allowed" onclick="activateSupportAbility('boost')" title="Combat Boost - 2x Attack Speed for all towers for 10 seconds" style="display: none;">
        <span class="material-symbols-outlined text-2xl">speed</span>
        <span class="text-xs font-bold mt-1">Boost</span>
      </button>
    </div>
    
    <!-- Tower Upgrade Panel -->
    <div id="upgradePanel" class="absolute top-20 left-4 bg-black/90 backdrop-blur-sm rounded-lg p-4 min-w-64 border-2 border-primary" style="display: none;">
      <div class="flex items-center justify-between mb-3">
        <h3 id="upgradeTowerName" class="text-white text-lg font-bold">Tower Upgrade</h3>
        <button onclick="event.stopPropagation(); event.preventDefault(); closeUpgradePanel(); return false;" class="text-white hover:text-gray-300">
          <span class="material-symbols-outlined">close</span>
        </button>
      </div>
      <div id="upgradeTowerInfo" class="text-white text-sm mb-3 space-y-1">
        <p>Level: <span id="upgradeLevel" class="text-primary font-bold">1</span></p>
        <p>Damage: <span id="upgradeDamage" class="text-primary font-bold">10</span></p>
        <p>Range: <span id="upgradeRange" class="text-primary font-bold">150</span></p>
        <div id="upgradeAbilityContainer" class="mt-2 pt-2 border-t border-white/20" style="display: none;">
          <p class="text-yellow-400 font-bold text-xs mb-1">âœ¨ Special Ability:</p>
          <p id="upgradeAbility" class="text-yellow-300 text-xs"></p>
        </div>
      </div>
      <button id="upgradeButton" onclick="event.stopPropagation(); event.preventDefault(); upgradeSelectedTower(); return false;" class="w-full bg-primary text-background-dark py-2 rounded font-bold hover:bg-primary/90 transition-colors">
        Upgrade (<span id="upgradeCost" class="text-red-500">50</span> gold)
      </button>
      <button onclick="event.stopPropagation(); event.preventDefault(); sellSelectedTower(); return false;" class="w-full bg-red-600 text-white py-2 rounded font-bold mt-2 hover:bg-red-700 transition-colors">
        Sell Tower
      </button>
    </div>
    
    <!-- Inventory Panel -->
    <div id="inventoryPanel" class="absolute top-20 right-4 bg-black/80 backdrop-blur-sm rounded-lg p-4 min-w-64" style="display: none;">
      <div class="flex items-center justify-between mb-3">
        <h3 class="text-white text-lg font-bold">Tower Inventory</h3>
        <button onclick="toggleInventory()" class="text-white hover:text-gray-300">
          <span class="material-symbols-outlined">close</span>
        </button>
      </div>
      
      <div class="space-y-3">
        <div class="flex items-center justify-between p-2 bg-white/10 rounded">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-cover rounded" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
            <span class="text-white text-sm">Archer</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="archerInventoryCount" class="text-yellow-400 font-bold">0</span>
            <button onclick="equipTower('archer')" class="bg-primary text-black px-2 py-1 rounded text-xs font-bold">Equip</button>
          </div>
        </div>
        
        <div class="flex items-center justify-between p-2 bg-white/10 rounded">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-cover rounded tower-icon-crop" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
            <span class="text-white text-sm">Cannon</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="cannonInventoryCount" class="text-yellow-400 font-bold">0</span>
            <button onclick="equipTower('cannon')" class="bg-primary text-black px-2 py-1 rounded text-xs font-bold">Equip</button>
          </div>
        </div>
        
        <div class="flex items-center justify-between p-2 bg-white/10 rounded">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-cover rounded tower-icon-crop" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
            <span class="text-white text-sm">Mage</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="mageInventoryCount" class="text-yellow-400 font-bold">0</span>
            <button onclick="equipTower('mage')" class="bg-primary text-black px-2 py-1 rounded text-xs font-bold">Equip</button>
          </div>
        </div>
        
        <div class="flex items-center justify-between p-2 bg-white/10 rounded">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-cover rounded tower-icon-crop" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAgWa32e2tC7Oqj6xaGtLFsrHpCnGZoSIsZETl3koFGkh3Yfv1SePboDpMUSULj1vKGVTG6JMF3Gd2AU9n-_CiSbLUGvehd0ddTn0LBwHi8S308I5Lr6ln1iLbXVoLuz5GmpG9L0SPJx59H5LukjIwYxZJMeJ9LBth6JbeOytozhasJF-BhOqeMsP0x8wYKbVvp07CvjkFslQIvbwblvc3yMcF1VtJit-T9xEj0Tu1XCJ9XnlxHbEhfuk9icdcrtMKtxDHwYLCrJXA");'></div>
            <span class="text-white text-sm">Ice</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="iceInventoryCount" class="text-yellow-400 font-bold">0</span>
            <button onclick="equipTower('ice')" class="bg-primary text-black px-2 py-1 rounded text-xs font-bold">Equip</button>
          </div>
        </div>
        
        <div class="flex items-center justify-between p-2 bg-white/10 rounded">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-cover rounded tower-icon-crop" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
            <span class="text-white text-sm">Poison</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="poisonInventoryCount" class="text-yellow-400 font-bold">0</span>
            <button onclick="equipTower('poison')" class="bg-primary text-black px-2 py-1 rounded text-xs font-bold">Equip</button>
          </div>
        </div>
        
        <div class="flex items-center justify-between p-2 bg-white/10 rounded">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-cover rounded" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
            <span class="text-white text-sm">Lightning</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="lightningInventoryCount" class="text-yellow-400 font-bold">0</span>
            <button onclick="equipTower('lightning')" class="bg-primary text-black px-2 py-1 rounded text-xs font-bold">Equip</button>
          </div>
        </div>
        
        <div class="flex items-center justify-between p-2 bg-white/10 rounded">
          <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-cover rounded tower-icon-crop" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
            <span class="text-white text-sm">Support</span>
          </div>
          <div class="flex items-center gap-2">
            <span id="shieldInventoryCount" class="text-yellow-400 font-bold">0</span>
            <button onclick="equipTower('shield')" class="bg-primary text-black px-2 py-1 rounded text-xs font-bold">Equip</button>
          </div>
        </div>
      </div>
      
      <div class="mt-4 pt-3 border-t border-white/20">
        <button onclick="goToScreen('shop')" class="w-full bg-primary text-black py-2 rounded font-bold">
          Go to Shop
        </button>
      </div>
    </div>
  </main>
  
  <footer class="absolute bottom-0 left-0 right-0 z-10 flex flex-col gap-4 bg-gradient-to-t from-black/60 to-transparent p-4 pt-12">
    <div class="flex overflow-x-auto [-ms-scrollbar-style:none] [scrollbar-width:none] [&::-webkit-scrollbar]:hidden">
      <div class="flex items-stretch gap-3 pb-2">
        <div id="archerTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('archer')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-primary/80 shadow-lg shadow-primary/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Archer</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">100</p>
          </div>
        </div>
        <div id="cannonTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('cannon')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-white/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Cannon</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">150</p>
          </div>
        </div>
        <div id="mageTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('mage')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-white/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Mage</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">200</p>
          </div>
        </div>
        <div id="iceTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('ice')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-white/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAgWa32e2tC7Oqj6xaGtLFsrHpCnGZoSIsZETl3koFGkh3Yfv1SePboDpMUSULj1vKGVTG6JMF3Gd2AU9n-_CiSbLUGvehd0ddTn0LBwHi8S308I5Lr6ln1iLbXVoLuz5GmpG9L0SPJx59H5LukjIwYxZJMeJ9LBth6JbeOytozhasJF-BhOqeMsP0x8wYKbVvp07CvjkFslQIvbwblvc3yMcF1VtJit-T9xEj0Tu1XCJ9XnlxHbEhfuk9icdcrtMKtxDHwYLCrJXA");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Ice</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">200</p>
          </div>
        </div>
        <div id="poisonTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('poison')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-white/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Poison</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">150</p>
          </div>
        </div>
        <div id="lightningTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('lightning')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-white/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Lightning</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">250</p>
          </div>
        </div>
        <div id="shieldTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('shield')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-white/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Support</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">300</p>
          </div>
        </div>
        <div id="fireTowerOption" class="tower-option flex h-full flex-1 flex-col gap-2 rounded-lg min-w-32 text-center cursor-pointer hover:scale-105 transition-transform" onclick="selectTower('fire')">
          <div class="w-full bg-center bg-no-repeat aspect-square bg-cover rounded-lg flex flex-col border-2 border-white/20 tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
          <div>
            <p class="text-white text-base font-medium leading-normal">Fire</p>
            <p class="text-yellow-400 text-sm font-bold leading-normal">150</p>
          </div>
        </div>
      </div>
    </div>
    <div class="flex gap-3 items-center">
    </div>
  </footer>
</div>

<!-- Shop -->
<div id="shop" class="screen bg-background-light dark:bg-background-dark">
  <div class="flex items-center bg-background-light dark:bg-background-dark p-4 pb-2 justify-between sticky top-0 z-10">
    <div class="text-slate-800 dark:text-white flex size-12 shrink-0 items-center justify-start cursor-pointer" onclick="goToScreen('mainMenu')">
      <span class="material-symbols-outlined text-2xl">arrow_back</span>
    </div>
    <h2 class="text-slate-900 dark:text-white text-lg font-bold leading-tight tracking-[-0.015em] flex-1 text-center">Shop</h2>
    <div class="flex w-12 items-center justify-end"></div>
  </div>
  
  <div class="flex flex-wrap gap-4 p-4">
    <div class="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-4 bg-slate-200/50 dark:bg-white/5">
      <p class="text-slate-700 dark:text-slate-300 text-sm font-medium leading-normal">Gold</p>
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-amber-400 text-2xl">monetization_on</span>
        <p id="shopGoldDisplay" class="text-slate-900 dark:text-white tracking-light text-2xl font-bold leading-tight">500</p>
      </div>
    </div>
    <div class="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-4 bg-slate-200/50 dark:bg-white/5">
      <p class="text-slate-700 dark:text-slate-300 text-sm font-medium leading-normal">Gems</p>
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-sky-400 text-2xl">diamond</span>
        <p id="shopGemsDisplay" class="text-slate-900 dark:text-white tracking-light text-2xl font-bold leading-tight">0</p>
      </div>
    </div>
  </div>
  
  <div class="p-4 pb-20">
    <h3 class="text-white text-lg font-bold mb-4">Available Towers</h3>
    <div class="grid grid-cols-2 gap-4">
      <div id="shopArcherCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('archer')">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
        <p class="text-white font-bold">Archer Tower</p>
        <p class="text-gray-400 text-sm">Damage: 10 | Range: 150</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <p class="text-yellow-400 font-bold">100</p>
        </div>
        <p id="shopArcherStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
      <div id="shopCannonCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('cannon')">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
        <p class="text-white font-bold">Cannon Tower</p>
        <p class="text-gray-400 text-sm">Damage: 30 | Range: 100</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <p class="text-yellow-400 font-bold">1,000</p>
        </div>
        <p id="shopCannonStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
      <div id="shopMageCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('mage')">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
        <p class="text-white font-bold">Mage Tower</p>
        <p class="text-gray-400 text-sm">Damage: 40 | Range: 200 | Frozen Pass</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <p class="text-yellow-400 font-bold">5,000</p>
        </div>
        <p id="shopMageStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
      <div id="shopIceCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('ice')">
        <div class="aspect-square bg-cover bg-center rounded-lg" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAgWa32e2tC7Oqj6xaGtLFsrHpCnGZoSIsZETl3koFGkh3Yfv1SePboDpMUSULj1vKGVTG6JMF3Gd2AU9n-_CiSbLUGvehd0ddTn0LBwHi8S308I5Lr6ln1iLbXVoLuz5GmpG9L0SPJx59H5LukjIwYxZJMeJ9LBth6JbeOytozhasJF-BhOqeMsP0x8wYKbVvp07CvjkFslQIvbwblvc3yMcF1VtJit-T9xEj0Tu1XCJ9XnlxHbEhfuk9icdcrtMKtxDHwYLCrJXA");'></div>
        <p class="text-white font-bold">Ice Tower</p>
        <p class="text-gray-400 text-sm">Damage: 35 | Range: 120 | Frozen Pass</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <p class="text-yellow-400 font-bold">3,000</p>
        </div>
        <p id="shopIceStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
      <div id="shopPoisonCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('poison')">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
        <p class="text-white font-bold">Poison Tower</p>
        <p class="text-gray-400 text-sm">Damage: 25 | Range: 140 | Whispering Woods</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <p class="text-yellow-400 font-bold">2,000</p>
        </div>
        <p id="shopPoisonStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
      <div id="shopLightningCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('lightning')">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
        <p class="text-white font-bold">Lightning Tower</p>
        <p class="text-gray-400 text-sm">Damage: 50 | Range: 180 | Desert Oasis</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <p class="text-yellow-400 font-bold">10,000</p>
        </div>
        <p id="shopLightningStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
      <div id="shopShieldCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('shield')">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
        <p class="text-white font-bold">Support Tower</p>
        <p class="text-gray-400 text-sm">Damage: 15 | Range: 200 | Frozen Pass</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">monetization_on</span>
          <p class="text-yellow-400 font-bold">7,500</p>
        </div>
        <p id="shopShieldStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
      <div id="shopFireCard" class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4 cursor-pointer hover:border-primary transition-colors" onclick="buyTower('fire')">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
        <p class="text-white font-bold">Fire Tower</p>
        <p class="text-gray-400 text-sm">Damage: 250 | Range: 125 | Any Arena</p>
        <div class="flex items-center gap-2">
          <span class="material-symbols-outlined text-yellow-400 text-xl">diamond</span>
          <p class="text-yellow-400 font-bold">250</p>
        </div>
        <p id="shopFireStatus" class="text-primary text-xs font-bold text-center mt-1" style="display: none;">UNLOCKED</p>
      </div>
    </div>
    
    <div class="mt-6 p-4 bg-white/5 rounded-lg">
      <h4 class="text-white font-bold mb-2">Your Tower Inventory</h4>
      <div class="grid grid-cols-2 gap-2 text-sm">
        <div class="flex justify-between">
          <span class="text-gray-400">Archer Towers:</span>
          <span id="archerCount" class="text-white font-bold">0</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-400">Cannon Towers:</span>
          <span id="cannonCount" class="text-white font-bold">0</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-400">Mage Towers:</span>
          <span id="mageCount" class="text-white font-bold">0</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-400">Ice Towers:</span>
          <span id="iceCount" class="text-white font-bold">0</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-400">Poison Towers:</span>
          <span id="poisonCount" class="text-white font-bold">0</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-400">Lightning Towers:</span>
          <span id="lightningCount" class="text-white font-bold">0</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-400">Support Towers:</span>
          <span id="shieldCount" class="text-white font-bold">0</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-400">Fire Towers:</span>
          <span id="fireCount" class="text-white font-bold">0</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// Game State
let gameState = {
  gold: 200, // Start with 200 gold for placing towers
  lives: 3, // Only 3 lives
  wave: 1,
  maxWave: 20,
  zombies: [],
  towers: [],
  barriers: [],
  projectiles: [],
  selectedTower: null,
  currentLevel: null,
  zombieSpawnTime: 0,
  waveActive: false,
  zombieReachedBase: false,
  frameCount: 0,
  autoWave: false,
  soundEnabled: true,
  musicEnabled: true,
  notificationsEnabled: false,
  maxZombiesThisWave: 5, // Default zombie count for current wave
  zombiesSpawnedThisWave: 0, // Track zombies spawned this wave for line formation
  nextZombieSpawnTime: 0, // Time until next zombie spawns
  playerLevel: 1,
  playerName: 'Player123', // Player's display name
  gamesPlayed: 0,
  experience: 0,
  experienceToNext: 2, // Start with 2 EXP needed for level 2
  unlockedTowers: {
    archer: true, // Start with archer unlocked
    cannon: false,
    mage: false,
    ice: false,
    poison: false,
    lightning: false,
    shield: false,
    fire: false
  },
  equippedTowers: ['archer'], // Equipped towers for loadout (max 5)
  frozenMapUnlocked: false, // Locked until wave 20
  desertMapUnlocked: false, // Locked until frozen map completed
  shopGold: 100, // Start with 100 shop gold for unlocking towers
  gems: 0, // Gems currency for special purchases (quest rewards)
  bossSpawned: false, // Track if boss has been spawned
  quests: [], // Current active quests
  questRefreshTime: null, // Time when quests will refresh (5 minutes)
  completedQuests: [], // Track completed quests to prevent duplicates
  questProgress: {}, // Track progress for each quest type
  gamePaused: false, // Track if game is paused
  fastForward: false, // Track fast forward state
  gameSpeed: 1.0, // Current game speed multiplier
  zombiesKilled: 0, // Track zombies killed this game
  towersPlaced: 0, // Track towers placed this game
  selectedTowerForUpgrade: null, // Track which tower is selected for upgrade
  poisonClouds: [], // Track poison clouds from poison tower ability
  desertDecor: [], // Decorative elements for desert map
  sandstorm: null, // Sandstorm state for desert map
  testMode: false, // Test mode is always disabled by default
  countdownTimer: 0, // Countdown timer before wave starts (0 = no countdown)
  countdownInterval: null, // Interval for countdown timer
  countdownShownThisRound: false, // Track if countdown has been shown for this round
  allTowersBoostUntil: null, // Global combat boost timer (support tower ability)
  supportBoostCooldownUntil: null // Support tower boost ability cooldown
};

let gameLoop;
let gameCanvas, ctx;
let path = [
  {x: 0, y: 300},
  {x: 200, y: 300},
  {x: 200, y: 100},
  {x: 400, y: 100},
  {x: 400, y: 500},
  {x: 800, y: 500}
];

function goToScreen(screenName) {
  console.log('Going to screen:', screenName);
  console.log('Current gameState:', gameState);
  
  // Hide all screens using direct DOM manipulation
  document.querySelectorAll('.screen').forEach(screen => {
    screen.style.display = 'none';
    screen.classList.remove('active');
  });
  
  // Show target screen using direct DOM manipulation
  const targetScreen = document.getElementById(screenName);
  if (targetScreen) {
    targetScreen.style.display = 'flex';
    targetScreen.style.flexDirection = 'column';
    targetScreen.classList.add('active');
    targetScreen.style.position = 'fixed';
    targetScreen.style.top = '0';
    targetScreen.style.left = '0';
    targetScreen.style.right = '0';
    targetScreen.style.bottom = '0';
    targetScreen.style.width = '100%';
    targetScreen.style.zIndex = '100';
    console.log('Showing screen:', screenName);
  } else {
    console.error('Screen not found:', screenName);
    return;
  }
  
  // Handle special cases
  if (screenName === 'inGame') {
    console.log('Initializing game...');
    
    // Update background first
    updateBackground();
    
    initGame();
    updateTowerVisibility();
    
    // Ensure wave button is visible when entering game
    setTimeout(() => {
      const waveButton = document.getElementById('waveButton');
      if (waveButton) {
        if (gameState.autoWave) {
          // Auto wave is ON - hide the button
          waveButton.style.display = 'none';
        } else {
          // Auto wave is OFF - show the button
          waveButton.style.display = 'block';
          waveButton.textContent = `Start Wave ${gameState.wave}`;
        }
      }
    }, 50);
  } else if (screenName === 'shop') {
    console.log('Updating shop UI...');
    updateShopUI();
  } else if (screenName === 'inventory') {
    console.log('Updating inventory UI...');
    updateInventoryScreenUI();
  } else if (screenName === 'mainMenu') {
    console.log('Updating main menu UI...');
    // Stop game loop when exiting to main menu
    if (gameLoop) {
      clearInterval(gameLoop);
      gameLoop = null;
    }
    updateMainMenuUI();
  } else if (screenName === 'levelSelection') {
    console.log('Updating level selection UI...');
    // Clear selected level when entering level selection (unless already in game)
    if (!gameState.waveActive) {
      gameState.currentLevel = null;
    }
    updateLevelSelectionUI();
  } else if (screenName === 'rewards') {
    console.log('Updating rewards UI...');
    updateRewardsUI();
  } else if (screenName === 'settings') {
    console.log('Updating settings UI...');
    updateSettingsUI();
  } else if (screenName === 'mainMenu') {
    // Auto-save when returning to main menu
    autoSave();
  }
}

function updateSettingsUI() {
  // Update settings toggles based on current state
  updateSettingToggle('soundToggle', 'soundToggleThumb', gameState.soundEnabled);
  updateSettingToggle('musicToggle', 'musicToggleThumb', gameState.musicEnabled);
  updateSettingToggle('notificationsToggle', 'notificationsToggleThumb', gameState.notificationsEnabled);
}

function startGame() {
  // Check if a level is selected
  if (!gameState.currentLevel) {
    alert('Please select a level first!');
    return;
  }
  
  console.log('Starting new game - Current state before reset: Lives:', gameState.lives, 'Gold:', gameState.gold);
  
  // Preserve player progression when starting a new game
  const savedUnlockedTowers = gameState.unlockedTowers || {archer: true, cannon: false, mage: false, ice: false, poison: false, lightning: false, shield: false, fire: false};
  const savedEquippedTowers = gameState.equippedTowers && Array.isArray(gameState.equippedTowers) ? gameState.equippedTowers : ['archer'];
  const savedPlayerLevel = gameState.playerLevel || 1;
  const savedGamesPlayed = gameState.gamesPlayed || 0;
  const savedExperience = gameState.experience || 0;
  const savedExperienceToNext = gameState.experienceToNext || 2;
  const savedFrozenMapUnlocked = gameState.frozenMapUnlocked || false;
  const savedDesertMapUnlocked = gameState.desertMapUnlocked || false;
  const savedShopGold = gameState.shopGold || 100;
  const savedCurrentLevel = gameState.currentLevel || 'woods';
  
  // Preserve admin mode (test mode) if it was enabled
  const wasAdminMode = gameState.testMode === true;
  
  // IMPORTANT: Clear all game-specific state for a fresh start
  gameState = {
    gold: wasAdminMode ? 999999 : 300, // Preserve unlimited gold if admin mode was enabled
    testMode: wasAdminMode, // Preserve test mode if admin mode was enabled
    lives: 3, // Always start with 3 lives
    wave: 1, 
    maxWave: 20, 
    zombies: [], // Clear all zombies
    towers: [], // Clear all towers - start fresh
    barriers: [], // Clear all barriers
    projectiles: [], // Clear all projectiles
    selectedTower: null, // Clear selected tower
    zombieSpawnTime: 0, 
    waveActive: false,
    zombieReachedBase: false,
    frameCount: 0,
    soundEnabled: true,
    autoWave: true, // Always auto-start waves
    maxZombiesThisWave: 5, // Default zombie count for current wave
    zombiesSpawnedThisWave: 0, // Reset zombie spawn counter
    nextZombieSpawnTime: 0, // Reset next spawn time
    playerLevel: savedPlayerLevel,
    gamesPlayed: savedGamesPlayed,
    experience: savedExperience,
    experienceToNext: savedExperienceToNext || (savedPlayerLevel === 1 ? 2 : Math.min(8, 2 + savedPlayerLevel)),
    unlockedTowers: savedUnlockedTowers,
    equippedTowers: savedEquippedTowers,
    frozenMapUnlocked: savedFrozenMapUnlocked,
    desertMapUnlocked: savedDesertMapUnlocked,
    shopGold: savedShopGold,
    bossSpawned: false, // Reset boss spawn status
    currentLevel: savedCurrentLevel,
    gamePaused: false, // Reset pause state
    fastForward: false, // Reset fast forward
    gameSpeed: 1.0, // Reset speed
    zombiesKilled: 0, // Reset kill counter
    towersPlaced: 0, // Reset tower counter
    selectedTowerForUpgrade: null, // Clear upgrade selection
    poisonClouds: [], // Clear poison clouds
    desertDecor: [], // Clear desert decorations
    sandstorm: null, // Clear sandstorm
    countdownTimer: 0, // Reset countdown timer
    countdownInterval: null, // Clear countdown interval
    countdownShownThisRound: false // Reset countdown flag for new round
  };
  
  // Clear any existing countdown interval
  if (gameState.countdownInterval) {
    clearInterval(gameState.countdownInterval);
    gameState.countdownInterval = null;
  }
  
  console.log('New game started - Lives:', gameState.lives, 'Gold:', gameState.gold);
  goToScreen('inGame');
  
  // Update background based on level
  setTimeout(() => {
    const gameCanvas = document.getElementById('gameCanvas');
    if (gameCanvas) {
      if (gameState.currentLevel === 'frozen') {
        gameCanvas.style.background = '#B0E0E6';
        gameCanvas.style.backgroundImage = 'linear-gradient(to bottom, #B0E0E6 0%, #87CEEB 20%, #E0F6FF 50%, #F0F8FF 70%, #E6F3FF 100%), radial-gradient(circle at 20% 30%, rgba(255,255,255,0.3) 0%, transparent 50%), radial-gradient(circle at 80% 70%, rgba(255,255,255,0.2) 0%, transparent 50%)';
      } else if (gameState.currentLevel === 'desert') {
        gameCanvas.style.background = 'linear-gradient(to bottom, #F4A460 0%, #DEB887 50%, #D2B48C 100%)';
        gameCanvas.style.backgroundImage = '';
      } else {
        gameCanvas.style.background = 'url("https://lh3.googleusercontent.com/aida-public/AB6AXuAhRmudF6JG9I9TrKfrO1Ir8dDuranU-hE3Wd8GJmlyLtNwpQkrWzOPu6a5oB0EYyTkKvwm5KbrbEH_0BGLmKx23TKFFKKk8axIFgMO7NGK5LFxElqvjKx4WAPCT8_iYOyUy-aVvotgAeAQ8PmWKnpa0s6NYPcQynodajwoVPGhg_da3gDoKHv3rZfG-gf9ePXjdo9HTfeSosKo1y2PLUvWeB67f_CIvzny9fwYa0oHzjbVP36xCp5o-sLQ4-FdalLIzjFNyQ3Ly-M") center/cover';
        gameCanvas.style.backgroundImage = '';
      }
    }
    
    // Start countdown timer only once at the start of the round (wave 1)
    if (gameState.wave === 1 && !gameState.waveActive && !gameState.countdownShownThisRound) {
      startCountdownTimer();
      gameState.countdownShownThisRound = true; // Mark that countdown has been shown
    } else if (gameState.wave === 1 && !gameState.waveActive && gameState.countdownShownThisRound) {
      // If countdown was already shown, start wave immediately
      startWave();
    }
  }, 100);
}

function startCountdownTimer() {
  // Clear any existing countdown
  if (gameState.countdownInterval) {
    clearInterval(gameState.countdownInterval);
  }
  
  // Set countdown to 10 seconds
  gameState.countdownTimer = 10;
  
  // Show countdown display
  const countdownTimerEl = document.getElementById('countdownTimer');
  const countdownTextEl = document.getElementById('countdownText');
  if (countdownTimerEl) countdownTimerEl.style.display = 'block';
  if (countdownTextEl) countdownTextEl.textContent = gameState.countdownTimer;
  
  // Update countdown every second
  gameState.countdownInterval = setInterval(() => {
    gameState.countdownTimer--;
    
    if (countdownTextEl) {
      countdownTextEl.textContent = gameState.countdownTimer;
    }
    
    // When countdown reaches 0, start the wave
    if (gameState.countdownTimer <= 0) {
      clearInterval(gameState.countdownInterval);
      gameState.countdownInterval = null;
      gameState.countdownTimer = 0;
      
      // Hide countdown display
      if (countdownTimerEl) countdownTimerEl.style.display = 'none';
      
      // Start the wave
      startWave();
    }
  }, 1000);
}

function toggleSound() {
  gameState.soundEnabled = !gameState.soundEnabled;
  const icon = document.getElementById('soundIcon');
  if (icon) icon.textContent = gameState.soundEnabled ? 'volume_up' : 'volume_off';
  
  if (gameState.soundEnabled) {
    // Play a click sound
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency = 440;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.5);
    } catch(e) {}
  }
}

function toggleSetting(setting) {
  if (setting === 'sound') {
    gameState.soundEnabled = !gameState.soundEnabled;
    updateSettingToggle('soundToggle', 'soundToggleThumb', gameState.soundEnabled);
  } else if (setting === 'music') {
    gameState.musicEnabled = !gameState.musicEnabled;
    updateSettingToggle('musicToggle', 'musicToggleThumb', gameState.musicEnabled);
  } else if (setting === 'notifications') {
    gameState.notificationsEnabled = !gameState.notificationsEnabled;
    updateSettingToggle('notificationsToggle', 'notificationsToggleThumb', gameState.notificationsEnabled);
  }
  autoSave(); // Auto-save settings changes
}

function updateSettingToggle(buttonId, thumbId, enabled) {
  const button = document.getElementById(buttonId);
  const thumb = document.getElementById(thumbId);
  if (button && thumb) {
    if (enabled) {
      button.classList.remove('bg-white/20');
      button.classList.add('bg-primary');
      thumb.style.transform = 'translateX(0)';
    } else {
      button.classList.remove('bg-primary');
      button.classList.add('bg-white/20');
      thumb.style.transform = 'translateX(24px)';
    }
  }
}

function togglePause() {
  gameState.gamePaused = !gameState.gamePaused;
  const pauseBtn = document.getElementById('pauseBtn');
  if (pauseBtn) {
    const icon = pauseBtn.querySelector('.material-symbols-outlined');
    if (icon) {
      icon.textContent = gameState.gamePaused ? 'play_arrow' : 'pause';
    }
    pauseBtn.title = gameState.gamePaused ? 'Resume' : 'Pause';
  }
}

function toggleFastForward() {
  gameState.fastForward = !gameState.fastForward;
  gameState.gameSpeed = gameState.fastForward ? 2.0 : 1.0;
  const fastForwardBtn = document.getElementById('fastForwardBtn');
  if (fastForwardBtn) {
    if (gameState.fastForward) {
      fastForwardBtn.classList.add('bg-primary/50');
    } else {
      fastForwardBtn.classList.remove('bg-primary/50');
    }
    fastForwardBtn.title = gameState.fastForward ? 'Normal Speed' : 'Fast Forward (2x Speed)';
  }
}

function startWave() {
  // Don't start wave if countdown is still active
  if (gameState.countdownTimer > 0) {
    return;
  }
  
  if (gameState.waveActive) {
    alert('Wave already in progress!');
    return;
  }
  
  if (gameState.wave > gameState.maxWave) {
    alert('You have completed all waves!');
    return;
  }
  
  gameState.waveActive = true;
  gameState.zombieSpawnTime = 0;
  
  // Set random zombie count for this wave (5-8 zombies)
  gameState.maxZombiesThisWave = 5 + Math.floor(Math.random() * 4);
  gameState.zombiesSpawnedThisWave = 0; // Reset zombie spawn counter for this wave
  gameState.nextZombieSpawnTime = 0; // Reset next spawn time
  
  updateUI();
  console.log('Wave', gameState.wave, 'started with', gameState.maxZombiesThisWave, 'zombies!');
}

// Auto wave is now always enabled - function removed

function updateBackground() {
  const gameCanvas = document.getElementById('gameCanvas');
  if (!gameCanvas) return;
  
  console.log('Updating background for level:', gameState.currentLevel);
  if (gameState.currentLevel === 'frozen') {
    // Icy frozen background with snow effect
    gameCanvas.style.background = '#B0E0E6';
    gameCanvas.style.backgroundImage = 'linear-gradient(to bottom, #B0E0E6 0%, #87CEEB 20%, #E0F6FF 50%, #F0F8FF 70%, #E6F3FF 100%), radial-gradient(circle at 20% 30%, rgba(255,255,255,0.3) 0%, transparent 50%), radial-gradient(circle at 80% 70%, rgba(255,255,255,0.2) 0%, transparent 50%)';
    console.log('Applied frozen background');
  } else if (gameState.currentLevel === 'desert') {
    // Enhanced desert background with sand dunes effect
    gameCanvas.style.background = '#F4A460';
    gameCanvas.style.backgroundImage = `
      linear-gradient(to bottom, #FFE4B5 0%, #F4A460 20%, #DEB887 40%, #D2B48C 60%, #CD853F 80%, #8B7355 100%),
      radial-gradient(ellipse at 30% 50%, rgba(255, 228, 181, 0.4) 0%, transparent 50%),
      radial-gradient(ellipse at 70% 30%, rgba(210, 180, 140, 0.3) 0%, transparent 50%),
      radial-gradient(ellipse at 50% 80%, rgba(205, 133, 63, 0.2) 0%, transparent 50%)
    `;
    console.log('Applied desert background');
  } else {
    // Default forest/woods background
    gameCanvas.style.background = 'url("https://lh3.googleusercontent.com/aida-public/AB6AXuAhRmudF6JG9I9TrKfrO1Ir8dDuranU-hE3Wd8GJmlyLtNwpQkrWzOPu6a5oB0EYyTkKvwm5KbrbEH_0BGLmKx23TKFFKKk8axIFgMO7NGK5LFxElqvjKx4WAPCT8_iYOyUy-aVvotgAeAQ8PmWKnpa0s6NYPcQynodajwoVPGhg_da3gDoKHv3rZfG-gf9ePXjdo9HTfeSosKo1y2PLUvWeB67f_CIvzny9fwYa0oHzjbVP36xCp5o-sLQ4-FdalLIzjFNyQ3Ly-M") center/cover';
    gameCanvas.style.backgroundImage = '';
    console.log('Applied woods background');
  }
}

function initGame() {
  gameCanvas = document.getElementById('gameCanvas');
  ctx = gameCanvas.getContext('2d');
  
  // Ensure towers array is empty when initializing a new game
  // This prevents old towers from appearing when starting a fresh game
  // Only clear if we're on wave 1 and not loading a saved game
  if (gameState.wave === 1 && !gameState.waveActive && gameState.towers.length > 0) {
    console.log('Clearing existing towers on new game start - wave:', gameState.wave, 'towers:', gameState.towers.length);
    gameState.towers = [];
    gameState.barriers = [];
    gameState.projectiles = [];
  }
  
  // Set background based on current level
  updateBackground();
  
  // Clear the canvas to remove any old drawings
  ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
  
  drawPath();
  if (gameLoop) clearInterval(gameLoop);
  gameLoop = setInterval(gameUpdate, 33); // 30 FPS
  
  // Add click and touch listeners for tower placement
  gameCanvas.addEventListener('click', handleCanvasClick);
  gameCanvas.addEventListener('touchend', handleCanvasTouch, { passive: false });
  
  // Handle canvas resize for mobile
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', () => {
    setTimeout(resizeCanvas, 100);
  });
  
  // Waves start automatically - no button needed
  gameState.autoWave = true;
  
  // Update UI to set correct gold text color for the current level
  updateUI();
  
  // Update tower visibility based on loadout
  updateTowerVisibility();
}

function resizeCanvas() {
  if (!gameCanvas) return;
  
  const container = gameCanvas.parentElement;
  if (!container) return;
  
  // Get container dimensions
  const containerWidth = container.clientWidth;
  const containerHeight = container.clientHeight;
  
  // Maintain 800x600 aspect ratio
  const aspectRatio = 800 / 600;
  let canvasWidth = containerWidth;
  let canvasHeight = containerWidth / aspectRatio;
  
  // If height is the constraint, use that instead
  if (canvasHeight > containerHeight) {
    canvasHeight = containerHeight;
    canvasWidth = containerHeight * aspectRatio;
  }
  
  // Set canvas display size (CSS)
  gameCanvas.style.width = canvasWidth + 'px';
  gameCanvas.style.height = canvasHeight + 'px';
  
  // Keep internal resolution at 800x600 for game logic
  // The canvas will scale automatically
}

function handleCanvasTouch(e) {
  // Prevent default to avoid scrolling/zooming
  e.preventDefault();
  
  // Get the touch point
  const touch = e.changedTouches[0];
  if (!touch) return;
  
  // Create a synthetic mouse event for compatibility
  const syntheticEvent = {
    clientX: touch.clientX,
    clientY: touch.clientY,
    target: e.target,
    preventDefault: () => e.preventDefault()
  };
  
  handleCanvasClick(syntheticEvent);
}

function handleCanvasClick(e) {
  const clickedElement = e.target;
  
  // IMPORTANT: Check if click is on upgrade panel FIRST, before any canvas calculations
  const upgradePanel = document.getElementById('upgradePanel');
  if (upgradePanel && upgradePanel.style.display !== 'none') {
    // Check if click is on the panel, any button, or any child element
    if (upgradePanel.contains(clickedElement) || 
        clickedElement.closest('#upgradePanel') ||
        clickedElement.closest('#upgradeButton') ||
        clickedElement.closest('button') && upgradePanel.querySelector('button')?.contains(clickedElement)) {
      // Let the panel buttons handle their own clicks - don't interfere
      return;
    }
  }
  
  const rect = gameCanvas.getBoundingClientRect();
  
  // First check if click is on a footer button (buttons handle their own clicks via pointer-events: auto)
  const footer = document.querySelector('#inGame footer');
  if (footer) {
    // Check if click target is actually a footer button/option
    if (footer.contains(clickedElement)) {
      // Check if it's an interactive element
      if (clickedElement.closest('.tower-option') ||
          clickedElement.tagName === 'BUTTON') {
        // Let the button handle its own click
        return;
      }
    }
  }
  
  // Calculate canvas coordinates - support both mouse and touch
  const clientX = e.clientX || (e.touches && e.touches[0]?.clientX) || (e.changedTouches && e.changedTouches[0]?.clientX);
  const clientY = e.clientY || (e.touches && e.touches[0]?.clientY) || (e.changedTouches && e.changedTouches[0]?.clientY);
  
  if (clientX === undefined || clientY === undefined) return;
  
  const x = (clientX - rect.left) * (gameCanvas.width / rect.width);
  const y = (clientY - rect.top) * (gameCanvas.height / rect.height);
  
  // Ensure coordinates are within canvas bounds
  // Canvas is 800x600 - allow full canvas interaction
  if (x < 0 || x > gameCanvas.width || y < 0 || y > gameCanvas.height) {
    return; // Click outside canvas bounds
  }
  
  // Check if clicked on an existing tower (for upgrades)
  let clickedOnTower = false;
  let clickedTowerIndex = -1;
  for (let i = 0; i < gameState.towers.length; i++) {
    const tower = gameState.towers[i];
    const dist = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
    if (dist < 30) { // Tower click radius
      clickedOnTower = true;
      clickedTowerIndex = i;
      
      // Check if this is the same tower already selected - if so, toggle (close) the panel
      if (gameState.selectedTowerForUpgrade && 
          gameState.selectedTowerForUpgrade.index === i &&
          upgradePanel && 
          upgradePanel.style.display !== 'none') {
        closeUpgradePanel();
      } else {
        // Open panel for this tower
        openUpgradePanel(tower, i);
      }
      gameState.selectedTower = null; // Clear placement selection
      return;
    }
  }
  
  // Close upgrade panel if clicking elsewhere (not on a tower and not on the panel)
  // But don't show any alerts when closing the panel
  if (!clickedOnTower && upgradePanel && upgradePanel.style.display !== 'none') {
    closeUpgradePanel();
    // Don't continue with tower placement logic when closing panel
    return;
  }
  
  // Check if clicked on path
  let tooClose = false;
  for (let i = 0; i < path.length - 1; i++) {
    const dist = pointToLineDist(x, y, path[i], path[i+1]);
    if (dist < 30) {
      tooClose = true;
      break;
    }
  }
  
  if (tooClose) {
    alert('Cannot place tower on the path!');
    return;
  }
  
  // Check if clicked on another tower (for placement)
  for (let i = 0; i < gameState.towers.length; i++) {
    const tower = gameState.towers[i];
    const dist = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
    if (dist < 40) { // Tower placement radius
      alert('Cannot place tower on another tower! Click on an existing tower to upgrade it.');
      return;
    }
  }
  
  // Add tower
  if (gameState.selectedTower) {
    const towerType = gameState.selectedTower.type;
    const towerCost = gameState.selectedTower.cost;
    
    if (gameState.unlockedTowers[towerType]) {
      // Check if player has enough gold (or in test mode)
      const hasEnoughGold = gameState.testMode || gameState.gold >= towerCost;
      if (hasEnoughGold) {
        // Clamp coordinates to valid canvas bounds
        const clampedX = Math.max(0, Math.min(gameCanvas.width, x));
        const clampedY = Math.max(0, Math.min(gameCanvas.height, y));
        
        // Ensure damage is set correctly (fire tower should be 250)
        const towerDamage = gameState.selectedTower.damage || (towerType === 'fire' ? 250 : 20);
        
        // Ensure range is set correctly (fire tower should be 200)
        const towerRange = gameState.selectedTower.range || (towerType === 'fire' ? 200 : 150);
        
        gameState.towers.push({
          x: clampedX, y: clampedY,
          color: gameState.selectedTower.color,
          damage: towerDamage,
          range: towerRange, // Use the ensured range value
          type: towerType,
          level: 1 // Start at level 1
        });
        
        // Debug: Log fire tower placement
        if (towerType === 'fire') {
          console.log(`Fire tower placed with damage: ${towerDamage}`);
        }
        // Only deduct gold if not in test mode
        if (!gameState.testMode) {
          gameState.gold -= towerCost;
        }
        const currentTowersPlaced = Number(gameState.towersPlaced) || 0;
        gameState.towersPlaced = currentTowersPlaced + 1; // Track towers placed
        checkQuestCompletion('placeTowers'); // Check quest progress
        updateUI();
        updateTowerAbilityButtons(); // Update ability buttons after placing tower
        // In test mode, don't show alert and keep selection active for multiple placements
        if (!gameState.testMode) {
          const goldMsg = gameState.gold;
          alert(`${towerType} tower placed for ${towerCost} gold! You have ${goldMsg} gold remaining.`);
        }
        // Keep selectedTower active so user can place more towers (especially in test mode)
        // Don't clear selection after placement
      } else {
        alert(`Not enough gold! You need ${towerCost} gold but only have ${gameState.gold}.`);
      }
    } else {
      alert(`You haven't unlocked ${towerType} towers yet! Buy one from the shop first.`);
    }
  } else {
    alert('Select a tower type first, then click here to place it!');
  }
}

function drawPath() {
  // Different path colors based on map type
  if (gameState.currentLevel === 'desert') {
    // Desert path - sandy yellow/tan colors
    ctx.strokeStyle = '#D2B48C'; // Tan color for desert path
    ctx.shadowColor = 'rgba(139, 90, 0, 0.3)';
    ctx.shadowBlur = 5;
  } else if (gameState.currentLevel === 'frozen') {
    // Frozen path - icy blue/white colors
    ctx.strokeStyle = '#E0F6FF';
    ctx.shadowColor = 'rgba(176, 224, 230, 0.3)';
    ctx.shadowBlur = 5;
  } else {
    // Default woods path - brown
    ctx.strokeStyle = '#8B4513';
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
  }
  
  ctx.lineWidth = 60;
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();
  
  // Reset shadow
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
}

function drawDesertDecorations() {
  if (gameState.currentLevel !== 'desert') return;
  
  // Draw cacti at various positions (avoiding the path)
  const cactiPositions = [
    {x: 50, y: 50},
    {x: 150, y: 200},
    {x: 300, y: 50},
    {x: 500, y: 100},
    {x: 650, y: 50},
    {x: 200, y: 450},
    {x: 450, y: 500},
    {x: 600, y: 450}
  ];
  
  cactiPositions.forEach(pos => {
    // Check if position is too close to path
    let tooClose = false;
    for (let i = 0; i < path.length - 1; i++) {
      const dist = pointToLineDist(pos.x, pos.y, path[i], path[i + 1]);
      if (dist < 50) {
        tooClose = true;
        break;
      }
    }
    
    if (!tooClose) {
      // Draw cactus
      ctx.fillStyle = '#228B22'; // Green
      ctx.beginPath();
      // Main body
      ctx.ellipse(pos.x, pos.y, 8, 20, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Left arm
      ctx.beginPath();
      ctx.ellipse(pos.x - 8, pos.y + 5, 5, 12, -0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Right arm
      ctx.beginPath();
      ctx.ellipse(pos.x + 8, pos.y + 5, 5, 12, 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // Small spikes
      ctx.fillStyle = '#2F4F2F';
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const spikeX = pos.x + Math.cos(angle) * 8;
        const spikeY = pos.y - 15 + (i % 2) * 10;
        ctx.fillRect(spikeX - 1, spikeY - 2, 2, 4);
      }
    }
  });
  
  // Draw some small rocks
  const rockPositions = [
    {x: 100, y: 450},
    {x: 350, y: 50},
    {x: 550, y: 100},
    {x: 700, y: 450}
  ];
  
  rockPositions.forEach(pos => {
    let tooClose = false;
    for (let i = 0; i < path.length - 1; i++) {
      const dist = pointToLineDist(pos.x, pos.y, path[i], path[i + 1]);
      if (dist < 50) {
        tooClose = true;
        break;
      }
    }
    
    if (!tooClose) {
      // Use a simple hash to get consistent "random" size per rock position
      const rockSeed = (pos.x * 7 + pos.y * 13) % 4;
      const rockSize = 6 + rockSeed;
      
      ctx.fillStyle = '#8B7355'; // Brown-gray rock color
      ctx.beginPath();
      ctx.arc(pos.x, pos.y, rockSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#A0826D';
      ctx.beginPath();
      ctx.arc(pos.x - 2, pos.y - 2, 3, 0, Math.PI * 2);
      ctx.fill();
    }
  });
}

function drawDetailedTower(tower) {
  const x = tower.x;
  const y = tower.y;
  const size = 25;
  
  // Draw tower base/platform
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(x - size, y - size, size * 2, size * 2);
  
  // Draw tower base shadow
  ctx.fillStyle = '#654321';
  ctx.fillRect(x - size + 2, y - size + 2, size * 2 - 4, size * 2 - 4);
  
  // Draw tower based on type
  if (tower.type === 'archer') {
    drawArcherTower(x, y, size);
  } else if (tower.type === 'cannon') {
    drawCannonTower(x, y, size);
  } else if (tower.type === 'mage') {
    drawMageTower(x, y, size);
  } else if (tower.type === 'ice') {
    drawIceTower(x, y, size);
  } else if (tower.type === 'poison') {
    drawPoisonTower(x, y, size);
  } else if (tower.type === 'lightning') {
    drawLightningTower(x, y, size);
  } else if (tower.type === 'shield') {
    drawShieldTower(x, y, size);
  } else if (tower.type === 'fire') {
    drawFireTower(x, y, size);
  }
  
  // Draw range circle when selected
  if (gameState.selectedTower === tower.type) {
    // Calculate effective range (doubled if cannon ability is active)
    let effectiveRange = tower.range || 150;
    const towerLevel = tower.level || 1;
    if (tower.type === 'cannon' && towerLevel >= 3 && tower.abilityActiveUntil && Date.now() < tower.abilityActiveUntil) {
      effectiveRange = effectiveRange * 2; // 100% more range (doubled)
    }
    ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(x, y, effectiveRange, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Draw upgrade level indicator
  const towerLevel = tower.level || 1;
  if (towerLevel > 1) {
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Lv.${towerLevel}`, x, y - size - 8);
    ctx.textAlign = 'left';
  }
  
  // Draw ability indicator (sparkle effect for level 3+ towers)
  if (tower.hasAbility) {
    // Draw sparkle particles around the tower
    const sparkleTime = Date.now() / 500;
    for (let i = 0; i < 4; i++) {
      const angle = (sparkleTime + i * Math.PI / 2) % (Math.PI * 2);
      const sparkleX = x + Math.cos(angle) * (size + 8);
      const sparkleY = y + Math.sin(angle) * (size + 8);
      ctx.fillStyle = '#FFD700';
      ctx.beginPath();
      ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Draw active ability indicator
  if (tower.abilityActiveUntil && Date.now() < tower.abilityActiveUntil) {
    const towerLevel = tower.level || 1;
    // Draw pulsing ring around tower
    const pulseTime = Date.now() / 300;
    const pulseRadius = size + 8 + Math.sin(pulseTime) * 3;
    ctx.strokeStyle = 'rgba(255, 215, 0, 0.8)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y, pulseRadius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Draw ability text based on tower type
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 10px Arial';
    ctx.textAlign = 'center';
    if (tower.type === 'archer' && towerLevel >= 3) {
      ctx.fillText('RAPID', x, y - size - 15);
    } else if (tower.type === 'cannon' && towerLevel >= 3) {
      ctx.fillText('RANGE', x, y - size - 15);
    }
    ctx.textAlign = 'left';
  }
  
  // Highlight tower if selected for upgrade
  if (gameState.selectedTowerForUpgrade && gameState.selectedTowerForUpgrade.tower === tower) {
    ctx.strokeStyle = 'rgba(23, 207, 23, 0.8)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y, size + 5, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Draw stun effect (passive support tower ability prevents stuns from showing)
  const hasSupportTowers = gameState.towers && gameState.towers.some(t => t.type === 'shield');
  if (!hasSupportTowers && tower.stunnedUntil && Date.now() < tower.stunnedUntil) {
    // Draw stun indicator (grayed out effect)
    ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
    ctx.fillRect(x - size - 5, y - size - 5, (size + 5) * 2, (size + 5) * 2);
    
    // Draw stun icon
    ctx.strokeStyle = '#FF0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x, y - size - 10, 8, 0, Math.PI * 2);
    ctx.stroke();
    ctx.font = 'bold 12px Arial';
    ctx.fillStyle = '#FF0000';
    ctx.textAlign = 'center';
    ctx.fillText('!', x, y - size - 7);
    ctx.textAlign = 'left'; // Reset text align
  }
}

function drawArcherTower(x, y, size) {
  // Tower structure
  ctx.fillStyle = '#D2B48C';
  ctx.fillRect(x - 8, y - 15, 16, 20);
  
  // Tower top
  ctx.fillStyle = '#F4A460';
  ctx.fillRect(x - 6, y - 18, 12, 8);
  
  // Archer figure
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(x - 3, y - 12, 6, 8);
  
  // Bow
  ctx.strokeStyle = '#654321';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x + 8, y - 8, 6, 0, Math.PI);
  ctx.stroke();
  
  // Arrow
  ctx.strokeStyle = '#C0C0C0';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x + 8, y - 8);
  ctx.lineTo(x + 12, y - 8);
  ctx.stroke();
}

function drawCannonTower(x, y, size) {
  // Tower structure
  ctx.fillStyle = '#696969';
  ctx.fillRect(x - 10, y - 15, 20, 20);
  
  // Cannon barrel
  ctx.fillStyle = '#2F4F4F';
  ctx.fillRect(x - 15, y - 8, 30, 6);
  
  // Cannon base
  ctx.fillStyle = '#708090';
  ctx.fillRect(x - 8, y - 12, 16, 8);
  
  // Cannonball
  ctx.fillStyle = '#000000';
  ctx.beginPath();
  ctx.arc(x - 12, y - 5, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Smoke effect
  ctx.fillStyle = 'rgba(192, 192, 192, 0.6)';
  ctx.beginPath();
  ctx.arc(x - 18, y - 8, 4, 0, Math.PI * 2);
  ctx.fill();
}

function drawMageTower(x, y, size) {
  // Tower structure
  ctx.fillStyle = '#9370DB';
  ctx.fillRect(x - 8, y - 15, 16, 20);
  
  // Tower top (pointed)
  ctx.fillStyle = '#8A2BE2';
  ctx.beginPath();
  ctx.moveTo(x, y - 20);
  ctx.lineTo(x - 8, y - 15);
  ctx.lineTo(x + 8, y - 15);
  ctx.closePath();
  ctx.fill();
  
  // Magic orb
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.arc(x, y - 8, 4, 0, Math.PI * 2);
  ctx.fill();
  
  // Magic sparkles
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  ctx.arc(x - 6, y - 12, 1, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + 6, y - 10, 1, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x - 2, y - 16, 1, 0, Math.PI * 2);
  ctx.fill();
}

function drawIceTower(x, y, size) {
  // Tower structure
  ctx.fillStyle = '#B0E0E6';
  ctx.fillRect(x - 8, y - 15, 16, 20);
  
  // Ice crystals
  ctx.fillStyle = '#E0FFFF';
  ctx.beginPath();
  ctx.moveTo(x, y - 20);
  ctx.lineTo(x - 4, y - 15);
  ctx.lineTo(x + 4, y - 15);
  ctx.closePath();
  ctx.fill();
  
  // Ice spikes
  ctx.fillStyle = '#87CEEB';
  ctx.beginPath();
  ctx.moveTo(x - 6, y - 12);
  ctx.lineTo(x - 8, y - 8);
  ctx.lineTo(x - 4, y - 8);
  ctx.closePath();
  ctx.fill();
  
  ctx.beginPath();
  ctx.moveTo(x + 6, y - 12);
  ctx.lineTo(x + 8, y - 8);
  ctx.lineTo(x + 4, y - 8);
  ctx.closePath();
  ctx.fill();
  
  // Frost effect
  ctx.strokeStyle = '#FFFFFF';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(x, y - 5, 6, 0, Math.PI * 2);
  ctx.stroke();
}

function drawPoisonTower(x, y, size) {
  // Tower structure
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(x - 8, y - 15, 16, 20);
  
  // Poison vat
  ctx.fillStyle = '#228B22';
  ctx.fillRect(x - 6, y - 12, 12, 8);
  
  // Poison bubbles
  ctx.fillStyle = '#32CD32';
  ctx.beginPath();
  ctx.arc(x - 2, y - 8, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + 2, y - 10, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x, y - 6, 1, 0, Math.PI * 2);
  ctx.fill();
  
  // Poison fumes
  ctx.fillStyle = 'rgba(50, 205, 50, 0.6)';
  ctx.beginPath();
  ctx.arc(x - 4, y - 16, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + 4, y - 18, 2, 0, Math.PI * 2);
  ctx.fill();
}

function drawLightningTower(x, y, size) {
  // Tower structure
  ctx.fillStyle = '#4169E1';
  ctx.fillRect(x - 8, y - 15, 16, 20);
  
  // Lightning rod
  ctx.fillStyle = '#FFD700';
  ctx.fillRect(x - 1, y - 20, 2, 8);
  
  // Lightning bolt
  ctx.strokeStyle = '#FFFF00';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(x, y - 15);
  ctx.lineTo(x - 3, y - 8);
  ctx.lineTo(x + 2, y - 5);
  ctx.lineTo(x - 1, y - 2);
  ctx.stroke();
  
  // Electric sparks
  ctx.fillStyle = '#FFFFFF';
  ctx.beginPath();
  ctx.arc(x - 6, y - 10, 1, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(x + 6, y - 8, 1, 0, Math.PI * 2);
  ctx.fill();
}

function drawShieldTower(x, y, size) {
  // Tower structure
  ctx.fillStyle = '#C0C0C0';
  ctx.fillRect(x - 8, y - 15, 16, 20);
  
  // Barrier generator
  ctx.fillStyle = '#FFD700';
  ctx.beginPath();
  ctx.arc(x, y - 8, 6, 0, Math.PI * 2);
  ctx.fill();
  
  // Barrier generator border
  ctx.strokeStyle = '#FFA500';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y - 8, 6, 0, Math.PI * 2);
  ctx.stroke();
  
  // Barrier energy lines
  ctx.strokeStyle = '#FFFF00';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - 4, y - 4);
  ctx.lineTo(x + 4, y - 12);
  ctx.moveTo(x + 4, y - 4);
  ctx.lineTo(x - 4, y - 12);
  ctx.stroke();
  
  // Barrier field aura
  ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(x, y - 8, 15, 0, Math.PI * 2);
  ctx.stroke();
}

function drawFireTower(x, y, size) {
  // Flamethrower base - dark metal structure
  ctx.fillStyle = '#2F2F2F';
  ctx.fillRect(x - 10, y - 15, 20, 20);
  
  // Flamethrower fuel tank
  ctx.fillStyle = '#B22222';
  ctx.beginPath();
  ctx.arc(x, y - 8, 8, 0, Math.PI * 2);
  ctx.fill();
  
  // Tank details/stripes
  ctx.strokeStyle = '#8B0000';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x - 8, y - 5);
  ctx.lineTo(x + 8, y - 5);
  ctx.stroke();
  
  // Flamethrower nozzle/barrel
  ctx.fillStyle = '#1C1C1C';
  ctx.fillRect(x + 6, y - 10, 12, 4);
  
  // Nozzle tip
  ctx.fillStyle = '#FF4500';
  ctx.fillRect(x + 18, y - 11, 3, 6);
  
  // Pilot flame at tip (animated effect)
  const flameOffset = Math.sin(Date.now() / 100) * 2;
  ctx.fillStyle = '#FFA500';
  ctx.beginPath();
  ctx.arc(x + 22 + flameOffset, y - 8, 3, 0, Math.PI * 2);
  ctx.fill();
  
  // Inner flame glow
  ctx.fillStyle = '#FFFF00';
  ctx.beginPath();
  ctx.arc(x + 22 + flameOffset, y - 8, 1.5, 0, Math.PI * 2);
  ctx.fill();
  
  // Heat waves effect
  ctx.strokeStyle = 'rgba(255, 100, 0, 0.3)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x + 20, y - 12);
  ctx.lineTo(x + 25, y - 14);
  ctx.moveTo(x + 20, y - 4);
  ctx.lineTo(x + 25, y - 2);
  ctx.stroke();
}

function spawnZombie() {
  const isBossWave = gameState.wave === 20 && !gameState.bossSpawned;
  const isFrozenMap = gameState.currentLevel === 'frozen';
  const isDesertMap = gameState.currentLevel === 'desert';
  const isWoodsMap = !gameState.currentLevel || gameState.currentLevel === 'woods';
  const isHighWave = gameState.wave >= 15; // Wave 15+ gets special zombies (not in woods)
  const isArmoredWave = gameState.wave >= 10; // Wave 10+ gets armored zombies
  
  // Base stats - Weaker zombies overall
  let baseHealth = 60 + (gameState.wave - 1) * 8; // Reduced from 100+20 to 60+8 per wave
  let baseSpeed = Math.max(0.03, 0.03 + (gameState.wave - 1) * 0.001); // Slower base speed and gentler scaling per wave
  
  // Whispering Woods - Make it really easy
  if (isWoodsMap) {
    baseHealth = 30 + (gameState.wave - 1) * 3; // Even weaker: starts at 30, only +3 per wave
    // Speed stays the same for woods (already slow)
  }
  
  // Desert map zombie progression:
  // Waves 1-10: Normal and armored zombies only
  // Waves 10-15: Add tank and fast (speedy) zombies
  // Waves 15-20: Add all special zombies (ice, flying, explosive, regenerating)
  // Wave 20: Only normal zombies and boss (no special zombies)
  
  // Wave 8+ - Fast zombies (only outside woods, not in desert until wave 10)
  let isFast = false;
  if (!isWoodsMap && !isDesertMap && (gameState.wave >= 8 && gameState.wave < 10)) {
    // Guarantee more visibility of fast zombies early in Frozen
    if (!gameState._fastSpawnTick) gameState._fastSpawnTick = 0;
    gameState._fastSpawnTick++;
    if (gameState._fastSpawnTick % 2 === 0 || Math.random() < 0.5) {
      isFast = true;
      baseSpeed *= 1.8; // Fast zombies are 80% faster
      baseHealth *= 0.8; // But have 20% less health
    }
  }
  
  // Desert map: Fast zombies spawn on waves 10-15 (not wave 20)
  if (isDesertMap && gameState.wave >= 10 && gameState.wave < 15 && !isBossWave) {
    if (!gameState._fastSpawnTick) gameState._fastSpawnTick = 0;
    gameState._fastSpawnTick++;
    if (gameState._fastSpawnTick % 2 === 0 || Math.random() < 0.5) {
      isFast = true;
      baseSpeed *= 1.8; // Fast zombies are 80% faster
      baseHealth *= 0.8; // But have 20% less health
    }
  }
  
  // Wave 10+ - Add armored zombies (or wave 1+ in desert)
  let isArmored = false;
  if (isDesertMap && gameState.wave >= 1 && gameState.wave < 20) {
    // In desert, armored can spawn from wave 1-19 (not wave 20)
    if (Math.random() < 0.3) {
      isArmored = true;
      baseHealth *= 2; // Armored zombies have 2x health
    }
  } else if (isArmoredWave && !isHighWave) {
    // 50% chance of armored zombie at wave 10-14
    if (Math.random() < 0.5) {
      isArmored = true;
      baseHealth *= 2; // Armored zombies have 2x health
    }
  }
  
  // Wave 12+ - Tank zombies (only outside woods, or wave 10-15 in desert, not wave 20)
  let isTank = false;
  if (isDesertMap && gameState.wave >= 10 && gameState.wave < 15) {
    // Desert: Tank zombies spawn on waves 10-15 (not wave 20)
    if (!gameState._tankSpawnTick) gameState._tankSpawnTick = 0;
    gameState._tankSpawnTick++;
    if (gameState._tankSpawnTick % 3 === 0 || Math.random() < 0.4) {
      isTank = true;
      baseHealth *= 3; // Tank zombies have 3x health
      baseSpeed *= 0.6; // But are 40% slower
    }
  } else if (!isWoodsMap && !isDesertMap && (gameState.wave >= 12 && gameState.wave < 15)) {
    // Frozen map: Tank zombies spawn on waves 12-15
    if (!gameState._tankSpawnTick) gameState._tankSpawnTick = 0;
    gameState._tankSpawnTick++;
    if (gameState._tankSpawnTick % 3 === 0 || Math.random() < 0.4) {
      isTank = true;
      baseHealth *= 3; // Tank zombies have 3x health
      baseSpeed *= 0.6; // But are 40% slower
    }
  }
  
  // Wave 15+ - Add ice, flying, and explosive zombies (only outside woods; or wave 15-19 in desert, not wave 20)
  let isIceZombie = false;
  let isFlying = false;
  let isExplosive = false;
  if (isDesertMap && gameState.wave >= 15 && gameState.wave < 20) {
    // Desert: Special zombies spawn on waves 15-19 (not wave 20)
    // Cycle through special types to guarantee variety
    if (gameState._specialIndex === undefined) gameState._specialIndex = 0;
    const cycle = ['armored', 'ice', 'flying', 'explosive'];
    const pick = cycle[gameState._specialIndex % cycle.length];
    gameState._specialIndex++;
    if (pick === 'armored') {
      isArmored = true;
      baseHealth *= 2;
    } else if (pick === 'ice') {
      isIceZombie = true;
      baseHealth *= 1.5;
    } else if (pick === 'flying') {
      isFlying = true;
      baseSpeed *= 1.6;
      baseHealth *= 1.2;
    } else if (pick === 'explosive') {
      isExplosive = true;
      baseHealth *= 1.3;
    }
  } else if (!isWoodsMap && !isDesertMap && isHighWave) {
    // Frozen map: Special zombies spawn on waves 15+
    // Cycle through special types to guarantee variety
    if (gameState._specialIndex === undefined) gameState._specialIndex = 0;
    const cycle = ['armored', 'ice', 'flying', 'explosive'];
    const pick = cycle[gameState._specialIndex % cycle.length];
    gameState._specialIndex++;
    if (pick === 'armored') {
      isArmored = true;
      baseHealth *= 2;
    } else if (pick === 'ice') {
      isIceZombie = true;
      baseHealth *= 1.5;
    } else if (pick === 'flying') {
      isFlying = true;
      baseSpeed *= 1.6;
      baseHealth *= 1.2;
    } else if (pick === 'explosive') {
      isExplosive = true;
      baseHealth *= 1.3;
    }
  }
  
  // Wave 18+ - Regenerating zombies (only outside woods, or wave 15-19 in desert, not wave 20)
  let isRegenerating = false;
  if (isDesertMap && gameState.wave >= 15 && gameState.wave < 20) {
    // Desert: Regenerating zombies spawn on waves 15-19 (not wave 20)
    if (Math.random() < 0.2) {
      isRegenerating = true;
      baseHealth *= 1.4; // Regenerating zombies have 40% more health
    }
  } else if (!isWoodsMap && !isDesertMap && gameState.wave >= 18) {
    // Frozen map: Regenerating zombies spawn on waves 18+
    if (Math.random() < 0.25) {
      isRegenerating = true;
      baseHealth *= 1.4; // Regenerating zombies have 40% more health
    }
  }
  
  // Frozen and Desert maps make zombies harder (but still weaker than before)
  // Desert zombies are stronger than frozen zombies
  if (isDesertMap) {
    baseHealth *= 2.0; // Desert: 100% more health (stronger than frozen)
    baseSpeed *= 1.2; // Desert: 20% faster
  } else if (isFrozenMap) {
    baseHealth *= 1.5; // Frozen: 50% more health
    baseSpeed *= 1.1; // Frozen: 10% faster
  }
  
  
  // Boss wave modifications (boss only on wave 20) - Weaker bosses
  if (isBossWave) {
    // Boss health: Whispering Woods = 150 HP, others use multipliers
    if (isWoodsMap) {
      baseHealth = 150; // Fixed 150 HP for Whispering Woods boss
    } else {
      // Boss multipliers: Desert > Frozen
      const bossMultiplier = isDesertMap ? 3.5 : (isFrozenMap ? 3.0 : 2.5);
      baseHealth *= bossMultiplier;
    }
    baseSpeed *= 0.4; // Boss is much slower (was 0.7x, now 0.4x)
    gameState.bossSpawned = true; // Mark boss as spawned
  }
  
  gameState.zombies.push({
    x: path[0].x,
    y: path[0].y,
    progress: 0,
    health: baseHealth,
    maxHealth: baseHealth, // Store max health for health bar
    speed: baseSpeed,
    baseSpeed: baseSpeed,
    slowEffect: 0,
    slowDuration: 0,
    stunnedUntil: null, // Timestamp when stun effect ends
    size: isBossWave ? 50 : (isFlying ? 25 : (isTank ? 40 : (!isWoodsMap ? 35 : (isArmored ? 35 : (isFast ? 28 : 30))))), // In woods, keep sizes simple
    isBoss: isBossWave,
    isFrozen: isFrozenMap && !isIceZombie, // Frozen map zombies (but not ice zombies)
    isFrozenMap: isFrozenMap, // Track if from frozen map
    isArmored: isArmored,
    isIceZombie: isIceZombie,
    isFlying: isFlying,
    isFast: isFast,
    isTank: isTank,
    isExplosive: isExplosive,
    isRegenerating: isRegenerating,
    regenerationRate: isRegenerating ? 2 : 0 // Heal 2 HP per second
  });
}

function startWave() {
  gameState.waveActive = true;
  const btn = document.getElementById('waveButton');
  if (btn) {
    btn.style.display = 'none';
  }
  spawnZombie();
  gameState.zombieSpawnTime = 0;
}

function selectLevel(levelId) {
  // Check if frozen map is locked
  if (levelId === 'frozen' && !gameState.frozenMapUnlocked) {
    alert('Frozen Pass is locked! Complete Wave 20 in Whispering Woods to unlock it.');
    return;
  }
  
  // Check if desert map is locked
  if (levelId === 'desert' && !gameState.desertMapUnlocked) {
    alert('Desert Oasis is locked! Complete Frozen Pass to unlock it.');
    return;
  }
  
  gameState.currentLevel = levelId;
  console.log('Level selected:', levelId);
  
  // Set up different paths for different levels
  if (levelId === 'frozen') {
    // Ice map path - new challenging path
    path = [
      {x: 0, y: 250},
      {x: 150, y: 250},
      {x: 150, y: 350},
      {x: 300, y: 350},
      {x: 300, y: 150},
      {x: 450, y: 150},
      {x: 450, y: 300},
      {x: 600, y: 300},
      {x: 600, y: 100},
      {x: 750, y: 100},
      {x: 750, y: 400},
      {x: 800, y: 400}
    ];
  } else if (levelId === 'desert') {
    // Desert map path - very challenging with tight turns
    path = [
      {x: 0, y: 100},
      {x: 100, y: 100},
      {x: 100, y: 300},
      {x: 250, y: 300},
      {x: 250, y: 150},
      {x: 400, y: 150},
      {x: 400, y: 400},
      {x: 550, y: 400},
      {x: 550, y: 200},
      {x: 700, y: 200},
      {x: 700, y: 350},
      {x: 800, y: 350}
    ];
  } else {
    // Default woods map path
    path = [
      {x: 0, y: 300},
      {x: 200, y: 300},
      {x: 200, y: 150},
      {x: 400, y: 150},
      {x: 400, y: 350},
      {x: 600, y: 350},
      {x: 600, y: 200},
      {x: 800, y: 200}
    ];
  }
  
  // Update play button
  const playButton = document.getElementById('playButton');
  if (playButton) {
    playButton.onclick = () => startGame();
  }
}

function gameUpdate() {
  // Skip update if game is paused
  if (gameState.gamePaused) {
    return;
  }
  
  gameState.frameCount = (gameState.frameCount || 0) + 1; // Increment frame counter
  
  // Apply speed multiplier
  const speedMultiplier = gameState.gameSpeed || 1.0;
  
  // Update ability buttons visibility
  if (gameState.frameCount % 60 === 0) { // Update every second to avoid too many DOM updates
    updateTowerAbilityButtons();
  }
  
  ctx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
  drawPath();
  drawDesertDecorations(); // Draw desert decorations (cacti, rocks) if on desert map
  
  // Update barriers
  if (gameState.barriers) {
    gameState.barriers.forEach((barrier, index) => {
      barrier.duration--;
      
      // Calculate barrier position
      const segments = getPositionAtProgress(barrier.progress);
      barrier.x = segments.x;
      barrier.y = segments.y;
      
      // Draw barrier (use custom radius if available)
      const barrierRadius = barrier.radius || 20;
      ctx.fillStyle = 'rgba(255, 255, 0, 0.8)';
      ctx.beginPath();
      ctx.arc(barrier.x, barrier.y, barrierRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw barrier border
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(barrier.x, barrier.y, barrierRadius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Remove expired barriers
      if (barrier.duration <= 0) {
        gameState.barriers.splice(index, 1);
      }
    });
  }
  
  // Update poison clouds (from poison tower ability)
  if (gameState.poisonClouds) {
    for (let i = gameState.poisonClouds.length - 1; i >= 0; i--) {
      const cloud = gameState.poisonClouds[i];
      cloud.duration--;
      
      // Damage zombies in cloud
      gameState.zombies.forEach(zombie => {
        const dist = Math.sqrt((cloud.x - zombie.x) ** 2 + (cloud.y - zombie.y) ** 2);
        if (dist < cloud.radius) {
          if (cloud.duration % 60 === 0) { // Damage every second
            zombie.health -= cloud.damage;
          }
        }
      });
      
      // Draw poison cloud
      ctx.fillStyle = `rgba(50, 205, 50, ${0.3 * (cloud.duration / 600)})`;
      ctx.beginPath();
      ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Remove expired clouds
      if (cloud.duration <= 0) {
        gameState.poisonClouds.splice(i, 1);
      }
    }
  }
  
  // Update zombies - iterate backwards to safely remove dead zombies
  for (let i = gameState.zombies.length - 1; i >= 0; i--) {
    const zombie = gameState.zombies[i];
    
    // Check if zombie is stunned - if so, don't move
    const isStunned = zombie.stunnedUntil && Date.now() < zombie.stunnedUntil;
    
    // Check for barrier blocking before movement
    let isBlockedByBarrier = false;
    if (gameState.barriers) {
      gameState.barriers.forEach(barrier => {
        const barrierRadius = barrier.radius || 20;
        // Calculate barrier position
        const barrierSegments = getPositionAtProgress(barrier.progress);
        const dist = Math.sqrt((zombie.x - barrierSegments.x) ** 2 + (zombie.y - barrierSegments.y) ** 2);
        if (dist < barrierRadius + 5) { // Collision with barrier
          isBlockedByBarrier = true;
        }
      });
    }
    
    // Only move if not stunned and not blocked by barrier
    if (!isStunned && !isBlockedByBarrier) {
      zombie.progress += zombie.speed * speedMultiplier;
      const segments = getPositionAtProgress(zombie.progress);
      zombie.x = segments.x;
      zombie.y = segments.y;
    }
    
    // Handle slow effect countdown
    if (zombie.slowEffect > 0) {
      zombie.slowEffect--;
      if (zombie.slowEffect <= 0) {
        // Restore normal speed when slow effect wears off
        zombie.speed = zombie.baseSpeed;
      }
    }
    
    // Handle poison effect
    if (zombie.poisonEffect > 0) {
      zombie.poisonEffect--;
      if (zombie.poisonEffect % 60 === 0) { // Every second (60 frames)
        zombie.health -= zombie.poisonDamage || 5;
      }
      if (zombie.poisonEffect <= 0) {
        zombie.poisonEffect = 0;
        zombie.poisonDamage = 0;
      }
    }
    
    // Regenerating zombies heal over time
    if (zombie.isRegenerating && zombie.regenerationRate > 0) {
      if (zombie.health < zombie.maxHealth) {
        // Heal every 60 frames (1 second)
        if (gameState.frameCount % 60 === 0) {
          zombie.health = Math.min(zombie.maxHealth, zombie.health + zombie.regenerationRate);
        }
      }
    }
    
    
    // Draw zombie
    ctx.fillStyle = '#4a4a4a';
    ctx.beginPath();
    ctx.arc(zombie.x, zombie.y, zombie.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw zombie body with different color based on type
    if (zombie.isBoss) {
      ctx.fillStyle = '#ff0000'; // Red for boss zombies
    } else if (zombie.isTank) {
      ctx.fillStyle = '#556B2F'; // Dark olive for tank zombies
      // Draw heavy armor
      ctx.strokeStyle = '#2F4F2F';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(zombie.x, zombie.y, zombie.size, 0, Math.PI * 2);
      ctx.stroke();
    } else if (zombie.isExplosive) {
      ctx.fillStyle = '#FF4500'; // Orange-red for explosive zombies
      // Draw warning symbol
      ctx.strokeStyle = '#FF0000';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(zombie.x, zombie.y - zombie.size - 3);
      ctx.lineTo(zombie.x - 4, zombie.y - zombie.size + 2);
      ctx.lineTo(zombie.x + 4, zombie.y - zombie.size + 2);
      ctx.closePath();
      ctx.stroke();
    } else if (zombie.isRegenerating) {
      ctx.fillStyle = '#8A2BE2'; // Blue-violet for regenerating zombies
      // Draw healing aura
      ctx.strokeStyle = '#DA70D6';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(zombie.x, zombie.y, zombie.size + 3, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    } else if (zombie.isFast) {
      ctx.fillStyle = '#FF69B4'; // Hot pink for fast zombies
      // Draw speed lines
      ctx.strokeStyle = '#FF1493';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(zombie.x - zombie.size, zombie.y);
      ctx.lineTo(zombie.x - zombie.size - 5, zombie.y - 3);
      ctx.moveTo(zombie.x - zombie.size, zombie.y);
      ctx.lineTo(zombie.x - zombie.size - 5, zombie.y + 3);
      ctx.stroke();
    } else if (zombie.isArmored) {
      ctx.fillStyle = '#8B4513'; // Brown for armored zombies
      // Draw armor plates
      ctx.strokeStyle = '#696969';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(zombie.x - 8, zombie.y, 8, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(zombie.x + 8, zombie.y, 8, 0, Math.PI * 2);
      ctx.stroke();
    } else if (zombie.isFlying) {
      ctx.fillStyle = '#9370DB'; // Purple for flying zombies
      // Draw wings
      ctx.fillStyle = '#BA55D3';
      ctx.beginPath();
      ctx.arc(zombie.x - 12, zombie.y - 5, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(zombie.x + 12, zombie.y - 5, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#9370DB'; // Purple body
    } else if (zombie.isIceZombie) {
      ctx.fillStyle = '#00CED1'; // Deep turquoise for ice zombies
      // Draw ice crystals
      ctx.strokeStyle = '#E0FFFF';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(zombie.x, zombie.y - zombie.size);
      ctx.lineTo(zombie.x - 5, zombie.y - zombie.size + 5);
      ctx.lineTo(zombie.x + 5, zombie.y - zombie.size + 5);
      ctx.closePath();
      ctx.stroke();
    } else if (gameState.currentLevel === 'desert') {
      ctx.fillStyle = '#228B22'; // Green for desert map zombies
    } else if (zombie.isFrozen || zombie.isFrozenMap) {
      ctx.fillStyle = '#4A90E2'; // Blue tint for frozen map zombies
    } else if (zombie.slowEffect > 0) {
      ctx.fillStyle = '#4444ff'; // Blue tint for slowed zombies
    } else if (zombie.poisonEffect > 0) {
      ctx.fillStyle = '#00ff00'; // Green tint for poisoned zombies
    } else if (zombie.burning > 0) {
      ctx.fillStyle = '#ff8800'; // Orange tint for burning zombies
    } else {
      ctx.fillStyle = '#ff4444'; // Normal red color
    }
    ctx.beginPath();
    ctx.arc(zombie.x, zombie.y, zombie.size * 0.8, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw burning effect
    if (zombie.burning > 0) {
      zombie.burning--;
      // Draw flames around zombie
      for (let i = 0; i < 3; i++) {
        const flameAngle = (Date.now() / 100 + i * Math.PI * 2 / 3) % (Math.PI * 2);
        const flameX = zombie.x + Math.cos(flameAngle) * zombie.size;
        const flameY = zombie.y + Math.sin(flameAngle) * zombie.size - 5;
        
        ctx.fillStyle = '#FF4500';
        ctx.beginPath();
        ctx.arc(flameX, flameY, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        ctx.arc(flameX, flameY, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // Draw health bar for boss and tank zombies
    if (zombie.isBoss || zombie.isTank) {
      const barWidth = zombie.size * 2;
      const barHeight = 8;
      const barX = zombie.x - barWidth / 2;
      const barY = zombie.y - zombie.size - 15;
      
      // Background bar
      ctx.fillStyle = '#333333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // Health bar
      const healthPercentage = zombie.health / zombie.maxHealth;
      ctx.fillStyle = healthPercentage > 0.5 ? '#00ff00' : healthPercentage > 0.25 ? '#ffff00' : '#ff0000';
      ctx.fillRect(barX, barY, barWidth * healthPercentage, barHeight);
      
      // Border
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
    }
    
    // Draw stun indicator
    if (zombie.stunnedUntil && Date.now() < zombie.stunnedUntil) {
      ctx.fillStyle = '#FFFF00';
      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('STUN', zombie.x, zombie.y - zombie.size - 12);
      ctx.textAlign = 'left';
      
      // Draw yellow sparkle effect around stunned zombie
      ctx.strokeStyle = '#FFFF00';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(zombie.x, zombie.y, zombie.size + 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1.0;
    }
    
    // Process burn damage (15 damage per second for Inferno ability)
    if (zombie.onFire && zombie.onFire > Date.now() && zombie.burnDamage) {
      // Apply burn damage per frame (game runs at ~30 FPS)
      const burnDamagePerFrame = (zombie.burnDamage / 30) * speedMultiplier;
      zombie.health -= burnDamagePerFrame;
      
      // Draw burn indicator
      ctx.fillStyle = '#FF4500';
      ctx.font = 'bold 10px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('BURN', zombie.x, zombie.y - zombie.size - 12);
      ctx.textAlign = 'left';
    }
    
    // Check if zombie is dead (health <= 0) - REMOVE IT
    if (zombie.health <= 0) {
      // Zombie is dead - remove it and award gold/kills
      // Award gold for kill
      const killGold = zombie.isBoss ? 100 : zombie.isTank ? 15 : zombie.isRegenerating ? 12 : 10;
      if (!gameState.testMode) {
        gameState.gold += killGold;
      }
      
      // Award experience
      gameState.experience += 1;
      
      // Increment kill counter
      const currentKills = Number(gameState.zombiesKilled) || 0;
      gameState.zombiesKilled = currentKills + 1;
      
      // Track boss kill for quests
      if (zombie.isBoss) {
        checkQuestCompletion('killBoss');
      }
      
      // Track armored zombie kill for quests
      if (zombie.isArmored) {
        checkQuestCompletion('killArmored');
      }
      
      // Track tower placement for quests
      checkQuestCompletion('placeTowers');
      
      // Clear currentTarget for any fire towers that were targeting this zombie
      gameState.towers.forEach(t => {
        if (t.type === 'fire' && t.currentTarget === zombie) {
          t.currentTarget = null;
        }
      });
      
      // Remove zombie from array (safe since we're iterating backwards)
      gameState.zombies.splice(i, 1);
      
      // Update UI
      updateUI();
      
      // Don't continue processing this zombie since it's been removed
      continue; // Skip rest of zombie processing
    }
    
    // Check if reached end
    if (zombie.progress >= path.length - 1) {
      // Boss reaching base = instant game over
      if (zombie.isBoss) {
        console.log('Game Over! Boss reached the base!');
        clearInterval(gameLoop);
        showGameOver();
        return; // Exit the game loop
      }
      
      gameState.lives--;
      gameState.zombieReachedBase = true;
      
      // Show damage effect
      if (gameState.soundEnabled) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          oscillator.frequency = 200; // Low frequency for damage sound
          oscillator.type = 'sawtooth';
          gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.3);
        } catch(e) {}
      }
      
      // Clear currentTarget for any fire towers that were targeting this zombie
      gameState.towers.forEach(t => {
        if (t.type === 'fire' && t.currentTarget === zombie) {
          t.currentTarget = null;
        }
      });
      
      // Remove zombie that reached base (safe since we're iterating backwards)
      gameState.zombies.splice(i, 1);
      updateUI();
      
      // Check for game over
      if (gameState.lives <= 0) {
        console.log('Game Over! Lives reached 0. Resetting game state...');
        clearInterval(gameLoop);
        showGameOver();
        return; // Exit the game loop
      }
      
      continue; // Skip rest of processing for this zombie
    }
  }
  
  // Draw fire tower flame streams first (before other projectiles)
  gameState.towers.forEach(tower => {
    // Check if fire tower has a valid target - be very lenient
    if (tower.type === 'fire' && tower.currentTarget) {
      // Verify target is still valid and exists in zombies array
      const target = tower.currentTarget;
      const targetStillExists = gameState.zombies.includes(target);
      if (targetStillExists && target.health > 0) {
        // Draw flamethrower effect from tower to target
        const dx = target.x - tower.x;
        const dy = target.y - tower.y;
        const angle = Math.atan2(dy, dx);
        const distance = Math.sqrt(dx * dx + dy * dy);
        const time = Date.now() / 100; // For animation
        
        // Prevent division by zero or very small distances
        const safeDistance = Math.max(distance, 0.1);
        
        // Draw multiple flame particles in a cone shape (flamethrower effect)
      const numFlames = 12;
      for (let i = 0; i < numFlames; i++) {
        // Create cone spread effect
        const spreadAngle = (Math.random() - 0.5) * 0.4; // Cone spread
        const flameProgress = (i / numFlames) + (Math.random() * 0.3) + (Math.sin(time + i) * 0.1);
        const flameDistance = Math.min(safeDistance * flameProgress, safeDistance);
        
        // Add some wave motion to flames
        const waveOffset = Math.sin(time * 2 + i) * 3;
        const flameX = tower.x + Math.cos(angle + spreadAngle) * flameDistance + Math.cos(angle + Math.PI / 2) * waveOffset;
        const flameY = tower.y + Math.sin(angle + spreadAngle) * flameDistance + Math.sin(angle + Math.PI / 2) * waveOffset;
        
        // Flame size decreases with distance (larger at start, smaller at end)
        // Use safeDistance to prevent division issues
        const flameSize = Math.max(3, 10 - (flameDistance / safeDistance) * 6);
        const alpha = Math.max(0.3, 0.9 - (flameDistance / safeDistance) * 0.5);
        
        // Draw outer flame (orange/red)
        ctx.fillStyle = `rgba(255, ${Math.floor(100 + Math.random() * 50)}, 0, ${alpha})`;
        ctx.beginPath();
        ctx.arc(flameX, flameY, flameSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw inner flame (bright yellow/white)
        ctx.fillStyle = `rgba(255, 255, ${Math.floor(150 + Math.random() * 105)}, ${alpha + 0.2})`;
        ctx.beginPath();
        ctx.arc(flameX, flameY, flameSize * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw base flame stream (core line)
      ctx.strokeStyle = 'rgba(255, 165, 0, 0.6)';
      ctx.lineWidth = 8;
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(255, 100, 0, 0.8)';
      ctx.beginPath();
      ctx.moveTo(tower.x, tower.y);
      ctx.lineTo(target.x, target.y);
      ctx.stroke();
      
      // Draw inner core (brightest part)
      ctx.strokeStyle = 'rgba(255, 255, 200, 0.8)';
      ctx.lineWidth = 4;
      ctx.shadowBlur = 10;
      ctx.shadowColor = 'rgba(255, 255, 0, 0.9)';
      ctx.beginPath();
      ctx.moveTo(tower.x, tower.y);
      ctx.lineTo(target.x, target.y);
      ctx.stroke();
      
      // Reset shadow
      ctx.shadowBlur = 0;
      ctx.shadowColor = 'transparent';
      
      // Draw impact point at target (flame burst)
      // Make burst more visible when target is very close
      const burstRadius = distance < 30 ? 12 : 8; // Larger burst when close
      for (let i = 0; i < 5; i++) {
        const burstAngle = (Math.PI * 2 / 5) * i + time;
        const burstX = target.x + Math.cos(burstAngle) * burstRadius;
        const burstY = target.y + Math.sin(burstAngle) * burstRadius;
        
        ctx.fillStyle = `rgba(255, ${Math.floor(100 + Math.random() * 100)}, 0, 0.8)`;
        ctx.beginPath();
        ctx.arc(burstX, burstY, 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = `rgba(255, 255, ${Math.floor(150 + Math.random() * 105)}, 1)`;
        ctx.beginPath();
        ctx.arc(burstX, burstY, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      }
    }
  });
  
  // Support tower abilities are now manual via buttons (no automatic features)
  
  // Update towers
  gameState.towers.forEach(tower => {
    // Draw detailed tower
    drawDetailedTower(tower);
    
    // Find target
    let target = null;
    // Calculate effective range (base range * 2 if ability is active for cannon towers)
    let effectiveRange = tower.range || 150;
    const towerLevel = tower.level || 1;
    if (tower.type === 'cannon' && towerLevel >= 3 && tower.abilityActiveUntil && Date.now() < tower.abilityActiveUntil) {
      effectiveRange = effectiveRange * 2; // 100% more range (doubled)
    }
    
    // For fire towers, SIMPLIFIED LOGIC: Always use currentTarget if it exists and has health
    // This is the ONLY way to maintain continuous attack
    if (tower.type === 'fire' && tower.currentTarget) {
      const fireTarget = tower.currentTarget;
      
      // First check if target still exists in zombies array
      if (!gameState.zombies.includes(fireTarget)) {
        // Target was removed (reached base or killed), clear it
        tower.currentTarget = null;
      } else if (fireTarget.health > 0) {
        // Try to find the actual zombie - be very lenient (check by reference first, then position)
        let actualZombie = gameState.zombies.find(z => z === fireTarget);
        
        if (!actualZombie) {
          // If reference doesn't match, try position matching (very loose - 100 pixels)
          actualZombie = gameState.zombies.find(z => 
            Math.abs(z.x - fireTarget.x) < 100 && 
            Math.abs(z.y - fireTarget.y) < 100 && 
            z.health > 0
          );
        }
        
        if (actualZombie && actualZombie.health > 0) {
          // Use this target - NO range checks, just verify it exists and has health
          target = actualZombie;
          tower.currentTarget = actualZombie;
        } else {
          // Can't find it in array or it's dead, clear currentTarget
          tower.currentTarget = null;
        }
      } else {
        // Target has no health, clear it
        tower.currentTarget = null;
      }
    }
    
    // If no target found yet, find new closest target (for initial targeting or when currentTarget is lost)
    if (!target) {
      let minDist = effectiveRange + 1;
      gameState.zombies.forEach(zombie => {
        const dist = Math.sqrt((tower.x - zombie.x) ** 2 + (tower.y - zombie.y) ** 2);
        if (dist <= minDist) {
          minDist = dist;
          target = zombie;
        }
      });
    }
    
    if (target && target.health > 0) {
      // Check if tower is stunned (passive support tower ability prevents stuns)
      const hasSupportTowers = gameState.towers.some(t => t.type === 'shield');
      const isStunned = !hasSupportTowers && tower.stunnedUntil && Date.now() < tower.stunnedUntil;
      if (!isStunned) {
        // Fire towers do continuous laser beam damage
        if (tower.type === 'fire') {
          // Fire towers ALWAYS deal continuous damage while target is in range
          // Apply continuous damage every frame (scaled by speed)
          const towerDamage = tower.damage;
          if (!towerDamage || towerDamage <= 0) {
            console.error('Fire tower has invalid damage value:', towerDamage);
            tower.damage = 250; // Fix invalid damage
          }
          
          // Fire tower base damage - set for 500 DPS total
          const baseDamagePerSecond = tower.damage || 250;
          // Game loop runs at 33ms intervals (~30 FPS)
          // Check for global combat boost (support tower ability)
          const globalBoostMultiplier = (gameState.allTowersBoostUntil && Date.now() < gameState.allTowersBoostUntil) ? 2.0 : 1.0;
          // Calculate damage per frame: damage per second / frames per second
          let damagePerFrame = (baseDamagePerSecond / 30) * speedMultiplier * globalBoostMultiplier;
          
          // Fire tower minimum damage per frame - reduced
          // This ensures it can still damage zombies effectively
          if (damagePerFrame < 1.0) {
            damagePerFrame = 1.0 * speedMultiplier * globalBoostMultiplier;
          }
          
          // Fire does extra damage to ice zombies (2x damage - fire vs ice)
          if (target.isIceZombie) {
            damagePerFrame *= 2.0; // Double damage to ice zombies
          }
          
          // Fire tower deals 1.5x base damage (reduced from 3x for balance)
          damagePerFrame *= 1.5;
          
          // Debug: Log damage calculation
          if (gameState.frameCount % 30 === 0) {
            console.log(`Fire tower damage calc: base=${baseDamagePerSecond}, perFrame=${damagePerFrame.toFixed(2)}, speedMult=${speedMultiplier}`);
          }
          
          // Apply direct damage to target (this happens every frame while target is in range)
          // IMPORTANT: This damage is applied regardless of burn status
          const healthBefore = target.health;
          
          // CRITICAL: Always apply damage if target exists and has health
          if (target && target.health > 0) {
            // Apply damage - use Math.max to ensure it doesn't go below 0
            target.health -= damagePerFrame;
            if (target.health < 0) {
              target.health = 0;
            }
            
            // Debug: Log damage application frequently
            if (gameState.frameCount % 10 === 0) {
              const dist = Math.sqrt((tower.x - target.x)**2 + (tower.y - target.y)**2);
              console.log(`ðŸ”¥ FIRE DAMAGE: ${damagePerFrame.toFixed(2)} dmg â†’ health ${healthBefore.toFixed(1)} â†’ ${target.health.toFixed(1)}, dist=${dist.toFixed(1)}, regen=${target.isRegenerating ? 'YES' : 'NO'}`);
            }
            
            // Check if zombie died
            if (target.health <= 0) {
              console.log(`ðŸ”¥ FIRE TOWER KILLED ZOMBIE! Health went from ${healthBefore.toFixed(1)} to 0`);
            }
          } else {
            // Debug: Log why damage isn't being applied
            if (gameState.frameCount % 30 === 0) {
              console.log(`âŒ NO DAMAGE: target exists=${!!target}, health=${target ? target.health : 'N/A'}, damagePerFrame=${damagePerFrame.toFixed(2)}`);
            }
          }
          
          // Store target for drawing flamethrower effect
          // CRITICAL: ALWAYS set currentTarget for fire towers when attacking
          // This ensures the tower maintains lock-on even if target finding fails
          // NEVER let currentTarget be null while attacking
          tower.currentTarget = target;
          
          // Debug: Log that we're maintaining target
          if (gameState.frameCount % 60 === 0) {
            const dist = Math.sqrt((tower.x - target.x)**2 + (tower.y - target.y)**2);
            console.log(`ðŸ”¥ FIRE MAINTAINING TARGET: health=${target.health.toFixed(1)}, dist=${dist.toFixed(1)}, currentTarget=${!!tower.currentTarget}`);
          }
          
          // Debug: Log attack status
          if (gameState.frameCount % 30 === 0) {
            const dist = Math.sqrt((tower.x - target.x) ** 2 + (tower.y - target.y) ** 2);
            console.log(`Fire tower ATTACKING: dist=${dist.toFixed(1)}, range=${tower.range || 200}, health=${target.health.toFixed(1)}, damagePerFrame=${damagePerFrame.toFixed(2)}`);
          }
          
          // Apply/refresh burn effect if target is still alive
          // The burn effect is ADDITIONAL damage over time (separate from direct damage)
          // Refresh burn duration to a longer time (5 seconds) so it doesn't interfere with continuous attack
          if (target.health > 0) {
            // Always refresh the burn effect while the fire tower is attacking
            // Use longer duration (5 seconds) so it doesn't expire during continuous attack
            target.onFire = Date.now() + 5000; // 5 second burn (refreshed each frame while attacking)
            target.burnDamage = (tower.damage || 250) * 0.5; // Burn deals 50% of tower damage per second as additional DoT
          }
          
          // Boss stuns towers for 0.5 seconds when at half health or below (unless support towers are present)
          if (target.isBoss) {
            const hasSupportTowers = gameState.towers.some(t => t.type === 'shield');
            if (!hasSupportTowers) {
              const healthPercentage = target.health / target.maxHealth;
              if (healthPercentage <= 0.5) {
                tower.stunnedUntil = Date.now() + 500; // Stun for 0.5 seconds
              }
            }
          }
        } else {
          // Other towers use projectile system
          // Get attack cooldown based on tower type (in milliseconds)
          let attackCooldown = 300; // Default 300ms (0.3 seconds) for most towers
          
          // Check if tower has active ability (archer tower rapid fire) - only for level 3+
          let abilityMultiplier = 1.0;
          const towerLevel = tower.level || 1;
          if (tower.type === 'archer' && towerLevel >= 3 && tower.abilityActiveUntil && Date.now() < tower.abilityActiveUntil) {
            abilityMultiplier = 2.0; // 2x attack speed for archer tower ability
          }
          
          // Check for global combat boost (support tower ability)
          const globalBoostMultiplier = (gameState.allTowersBoostUntil && Date.now() < gameState.allTowersBoostUntil) ? 2.0 : 1.0;
          
          // Apply speed multiplier and ability multiplier to attack cooldown
          const effectiveAttackCooldown = (attackCooldown / speedMultiplier) / (abilityMultiplier * globalBoostMultiplier);
          
          // Create projectile when attacking (guaranteed hit)
          if (!tower.lastAttack || Date.now() - tower.lastAttack > effectiveAttackCooldown) {
          // Create projectile that will definitely hit
          const dx = target.x - tower.x;
          const dy = target.y - tower.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const speed = 15 * speedMultiplier; // Projectile speed scales with game speed
          
          // Store target's current position but allow projectile to track moving target
          gameState.projectiles.push({
            x: tower.x,
            y: tower.y,
            targetX: target.x,
            targetY: target.y,
            target: target, // Always track current target position
            damage: tower.damage || 10,
            type: tower.type,
            vx: (dx / distance) * speed,
            vy: (dy / distance) * speed,
            tower: tower,
            guaranteedHit: true // Mark for guaranteed hit system
          });
          
          tower.lastAttack = Date.now();
          }
        }
      } else {
        // If stunned, DON'T clear current target for fire towers - they should resume when unstunned
        // Fire towers maintain lock-on even when stunned briefly
      }
      // If stunned, tower can't attack and just draws its visual
    } else {
      // No target found in range - for fire towers, NEVER clear currentTarget here
      // The target finding logic above will handle recovery
      // Only clear if we're absolutely certain the target is dead
      if (tower.type === 'fire' && tower.currentTarget) {
        const prevTarget = tower.currentTarget;
        
        // Only clear if target health is 0 or negative AND it doesn't exist in array
        // Be very strict - only clear if we're 100% sure
        if (prevTarget.health <= 0) {
          // Check if it still exists in the array
          const stillExists = gameState.zombies.some(z => 
            z === prevTarget || 
            (Math.abs(z.x - prevTarget.x) < 50 && Math.abs(z.y - prevTarget.y) < 50)
          );
          
          // Only clear if it's dead AND not in array
          if (!stillExists) {
            tower.currentTarget = null;
            console.log('Fire tower cleared dead target');
          }
        }
        // Otherwise, keep currentTarget - it will be used next frame
      }
    }
  });
  
  // Update and draw projectiles
  if (gameState.projectiles) {
    for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
      const projectile = gameState.projectiles[i];
      
      // Skip fire tower projectiles - they use continuous laser beam system
      if (projectile.type === 'fire') {
        gameState.projectiles.splice(i, 1);
        continue;
      }
      
      // Remove projectile if target is invalid or already dead
      if (!projectile.target || projectile.target.health <= 0) {
        gameState.projectiles.splice(i, 1);
        continue;
      }
      
      // Update projectile to track moving target (guaranteed hit system)
      const dx = projectile.target.x - projectile.x;
      const dy = projectile.target.y - projectile.y;
      const distToTarget = Math.sqrt(dx * dx + dy * dy);
      const speed = 15 * speedMultiplier; // Projectile speed scales with game speed
      
      // Always move toward current target position
      if (distToTarget > 5) {
        projectile.vx = (dx / distToTarget) * speed;
        projectile.vy = (dy / distToTarget) * speed;
        projectile.x += projectile.vx;
        projectile.y += projectile.vy;
      } else {
        // Close enough to hit - guaranteed hit
        // Hit! Apply damage
        if (projectile.target) {
          let damageToApply = projectile.damage;
          
          // Lightning tower does extra damage to desert zombies (2x damage - lightning is strong against desert zombies)
          if (projectile.tower && projectile.tower.type === 'lightning' && gameState.currentLevel === 'desert') {
            damageToApply *= 2.0; // Double damage to desert zombies
          }
          
          // Lightning tower stuns zombies for 0.2 seconds
          if (projectile.tower && projectile.tower.type === 'lightning') {
            projectile.target.stunnedUntil = Date.now() + 200; // Stun for 0.2 seconds (200ms)
          }
          
          projectile.target.health -= damageToApply;
          
          // Boss stuns towers for 0.5 seconds when at half health or below (unless support towers are present)
          if (projectile.target.isBoss && projectile.tower) {
            const hasSupportTowers = gameState.towers.some(t => t.type === 'shield');
            if (!hasSupportTowers) {
              const healthPercentage = projectile.target.health / projectile.target.maxHealth;
              if (healthPercentage <= 0.5) {
                // Boss is at half health or below, stun the tower
                projectile.tower.stunnedUntil = Date.now() + 500; // Stun for 0.5 seconds
              }
            }
          }
          
          // Ice zombie slows down tower attack speed
          if (projectile.target.isIceZombie && projectile.tower) {
            projectile.tower.lastAttack = Date.now() + 300; // Add 0.3 seconds to attack cooldown
          }
          
          // Apply special effects based on tower type
          const tower = projectile.tower;
          if (tower) {
            if (tower.type === 'ice') {
              projectile.target.slowEffect = 120;
              projectile.target.slowDuration = 120;
              projectile.target.speed = projectile.target.baseSpeed * 0.3;
              
              // Level 3+ Ability: Frost Nova - Slows all enemies in range
              if (tower.hasAbility) {
                gameState.zombies.forEach(zombie => {
                  if (zombie !== projectile.target) {
                    const dist = Math.sqrt((tower.x - zombie.x) ** 2 + (tower.y - zombie.y) ** 2);
                    if (dist < tower.range) {
                      zombie.slowEffect = 180; // Longer slow
                      zombie.speed = zombie.baseSpeed * 0.2; // Slower
                    }
                  }
                });
              }
            } else if (tower.type === 'poison') {
              if (!projectile.target.poisonEffect) {
                projectile.target.poisonEffect = 300;
                projectile.target.poisonDamage = 5;
              }
              
              // Level 3+ Ability: Poison Cloud - Creates lingering poison area
              if (tower.hasAbility) {
                // Create poison cloud that damages enemies over time
                if (!gameState.poisonClouds) gameState.poisonClouds = [];
                gameState.poisonClouds.push({
                  x: projectile.target.x,
                  y: projectile.target.y,
                  radius: 80,
                  duration: 600, // Lasts 10 seconds
                  damage: 3
                });
              }
            } else if (tower.type === 'lightning') {
              // Chain lightning effect - damage nearby enemies
              const chainCount = tower.hasAbility ? 4 : 1; // Enhanced: jumps to 4 total enemies (was 1)
              const chainTargets = [projectile.target];
              let currentChainTarget = projectile.target;
              
              // First, collect all chain targets
              for (let chain = 0; chain < chainCount; chain++) {
                let closestZombie = null;
                let closestDist = 100; // Chain range
                
              gameState.zombies.forEach(zombie => {
                  if (!chainTargets.includes(zombie)) {
                    const dist = Math.sqrt((currentChainTarget.x - zombie.x) ** 2 + (currentChainTarget.y - zombie.y) ** 2);
                    if (dist < closestDist) {
                      closestDist = dist;
                      closestZombie = zombie;
                    }
                  }
                });
                
                if (closestZombie) {
                  let chainDamage = 15;
                  // Chain lightning also does extra damage to desert zombies (2x damage)
                  if (gameState.currentLevel === 'desert') {
                    chainDamage *= 2.0; // Double chain damage to desert zombies
                  }
                  // Chain lightning stuns zombies for 0.2 seconds
                  closestZombie.stunnedUntil = Date.now() + 200; // Stun for 0.2 seconds (200ms)
                  closestZombie.health -= chainDamage;
                  chainTargets.push(closestZombie);
                  currentChainTarget = closestZombie;
                } else {
                  break; // No more targets in range
                  }
                }
              
              // Draw continuous beam effect through all chain targets
              if (chainTargets.length > 1) {
                // Draw from tower to first target, then through all chain targets
                const beamPath = [tower, ...chainTargets];
                
                // Draw outer glow (wider, more transparent)
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.4)';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(beamPath[0].x, beamPath[0].y);
                for (let i = 1; i < beamPath.length; i++) {
                  ctx.lineTo(beamPath[i].x, beamPath[i].y);
                }
                ctx.stroke();
                
                // Draw middle layer (brighter)
                ctx.strokeStyle = 'rgba(255, 255, 150, 0.8)';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(beamPath[0].x, beamPath[0].y);
                for (let i = 1; i < beamPath.length; i++) {
                  ctx.lineTo(beamPath[i].x, beamPath[i].y);
                }
                ctx.stroke();
                
                // Draw inner core (brightest, electric blue-white)
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(beamPath[0].x, beamPath[0].y);
                for (let i = 1; i < beamPath.length; i++) {
                  ctx.lineTo(beamPath[i].x, beamPath[i].y);
                }
                ctx.stroke();
                
                // Draw sparkle effects at connection points
                ctx.fillStyle = '#FFFFFF';
                for (let i = 1; i < beamPath.length; i++) {
                  const x = beamPath[i].x;
                  const y = beamPath[i].y;
                  // Draw multiple sparkles around the connection point
                  for (let sparkle = 0; sparkle < 4; sparkle++) {
                    const angle = (Math.PI * 2 * sparkle) / 4;
                    const offsetX = Math.cos(angle) * 5;
                    const offsetY = Math.sin(angle) * 5;
                    ctx.beginPath();
                    ctx.arc(x + offsetX, y + offsetY, 2, 0, Math.PI * 2);
                    ctx.fill();
                  }
                }
                
                // Draw electric bolt effect on the beam (zigzag pattern)
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                for (let i = 0; i < beamPath.length - 1; i++) {
                  const start = beamPath[i];
                  const end = beamPath[i + 1];
                  const dx = end.x - start.x;
                  const dy = end.y - start.y;
                  const segments = 5;
                  
                  ctx.beginPath();
                  ctx.moveTo(start.x, start.y);
                  
                  for (let s = 1; s <= segments; s++) {
                    const t = s / segments;
                    const baseX = start.x + dx * (s - 1) / segments;
                    const baseY = start.y + dy * (s - 1) / segments;
                    const nextX = start.x + dx * s / segments;
                    const nextY = start.y + dy * s / segments;
                    
                    // Add random offset for zigzag effect
                    const perpX = -dy / Math.sqrt(dx * dx + dy * dy);
                    const perpY = dx / Math.sqrt(dx * dx + dy * dy);
                    const offset = (Math.random() - 0.5) * 8;
                    const midX = (baseX + nextX) / 2 + perpX * offset;
                    const midY = (baseY + nextY) / 2 + perpY * offset;
                    
                    ctx.lineTo(midX, midY);
                    ctx.lineTo(nextX, nextY);
                  }
                  ctx.stroke();
                }
                ctx.globalAlpha = 1.0;
              }
            } else if (tower.type === 'fire') {
              // Fire tower creates burning effect - damage nearby enemies
              const spreadRadius = tower.hasAbility ? 60 : 40; // Enhanced: larger spread
              gameState.zombies.forEach(zombie => {
                if (zombie !== projectile.target) {
                  const dist = Math.sqrt((projectile.target.x - zombie.x) ** 2 + (projectile.target.y - zombie.y) ** 2);
                  if (dist < spreadRadius) {
                    zombie.health -= tower.hasAbility ? 12 : 8; // Enhanced: more damage
                    // Add burning visual effect
                    zombie.burning = tower.hasAbility ? 90 : 60; // Enhanced: longer burn
                  }
                }
              });
            } else if (tower.type === 'shield') {
              // Support towers create temporary barriers in the middle of the path
              // Barriers are created automatically every 5 seconds (not on attack)
              // This is handled in the tower update loop below
            } else if (tower.type === 'archer') {
              // Level 3+ Ability: Piercing Shot - Arrows pierce through 2 enemies
              if (tower.hasAbility) {
                let pierceCount = 2;
                let currentTarget = projectile.target;
                const piercedTargets = [currentTarget];
                
                // Find next targets in line
                const dx = projectile.vx;
                const dy = projectile.vy;
                const angle = Math.atan2(dy, dx);
                
                gameState.zombies.forEach(zombie => {
                  if (pierceCount > 0 && !piercedTargets.includes(zombie)) {
                    // Check if zombie is in the path of the arrow
                    const zombieDx = zombie.x - currentTarget.x;
                    const zombieDy = zombie.y - currentTarget.y;
                    const zombieDist = Math.sqrt(zombieDx * zombieDx + zombieDy * zombieDy);
                    const zombieAngle = Math.atan2(zombieDy, zombieDx);
                    const angleDiff = Math.abs(angle - zombieAngle);
                    
                    if (zombieDist < 100 && (angleDiff < 0.5 || angleDiff > 5.78)) {
                      zombie.health -= projectile.damage * 0.7; // 70% damage to pierced enemies
                      piercedTargets.push(zombie);
                      pierceCount--;
                      currentTarget = zombie;
                    }
                  }
                });
              }
            } else if (tower.type === 'cannon') {
              // Level 3+ Ability: Splash Damage - Explosions damage nearby enemies
              if (tower.hasAbility) {
                const splashRadius = 80;
                gameState.zombies.forEach(zombie => {
                  if (zombie !== projectile.target) {
                    const dist = Math.sqrt((projectile.target.x - zombie.x) ** 2 + (projectile.target.y - zombie.y) ** 2);
                    if (dist < splashRadius) {
                      const splashDamage = projectile.damage * 0.5; // 50% splash damage
                      zombie.health -= splashDamage;
                      // Draw explosion visual
                      ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                      ctx.beginPath();
                      ctx.arc(projectile.target.x, projectile.target.y, splashRadius, 0, Math.PI * 2);
                      ctx.fill();
                    }
                  }
                });
              }
            } else if (tower.type === 'mage') {
              // Level 3+ Ability: Magic Overload - Double damage to armored enemies
              if (tower.hasAbility && projectile.target.isArmored) {
                projectile.target.health -= projectile.damage; // Double damage (already applied once)
              }
            }
          }
          
          // Remove zombie if dead
          if (projectile.target.health <= 0) {
            const deadZombie = projectile.target;
            
          // Track zombie kill
          const projectileKills = Number(gameState.zombiesKilled) || 0;
          gameState.zombiesKilled = projectileKills + 1;
          
          // Track boss kill for quests
          if (deadZombie.isBoss) {
            checkQuestCompletion('killBoss');
          }
          
          // Track armored zombie kill for quests
          if (deadZombie.isArmored) {
            checkQuestCompletion('killArmored');
          }
            
            // Explosive zombies explode on death
            if (deadZombie.isExplosive) {
              const explosionRadius = 60;
              const explosionDamage = 30;
              
              // Damage nearby zombies
              gameState.zombies.forEach(zombie => {
                if (zombie !== deadZombie) {
                  const dist = Math.sqrt((deadZombie.x - zombie.x) ** 2 + (deadZombie.y - zombie.y) ** 2);
                  if (dist < explosionRadius) {
                    zombie.health -= explosionDamage;
                  }
                }
              });
              
              // Stun nearby towers (towers can't be damaged, only stunned)
              gameState.towers.forEach(tower => {
                const dist = Math.sqrt((deadZombie.x - tower.x) ** 2 + (deadZombie.y - tower.y) ** 2);
                if (dist < explosionRadius) {
                  // Stun tower for 1 second from explosion
                  tower.stunnedUntil = Date.now() + 1000;
                }
              });
              
              // Draw explosion effect
              ctx.fillStyle = '#FF4500';
              ctx.beginPath();
              ctx.arc(deadZombie.x, deadZombie.y, explosionRadius, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = '#FF0000';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(deadZombie.x, deadZombie.y, explosionRadius, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Gold rewards per zombie kill
            const killGold = deadZombie.isBoss ? 50 : 5; // 5 gold per normal zombie, 50 for boss
            const killShopGold = deadZombie.isBoss ? 150 : 15; // 15 shop gold per normal zombie, 150 for boss
            gameState.gold += killGold;
            gameState.shopGold += killShopGold;
            
            const index = gameState.zombies.indexOf(deadZombie);
            if (index > -1) {
              gameState.zombies.splice(index, 1);
            }
            updateUI();
            
            // Auto-save after earning gold (with debounce to avoid too many saves)
            if (!gameState._lastKillSave || Date.now() - gameState._lastKillSave > 5000) {
              autoSave();
              gameState._lastKillSave = Date.now();
            }
          }
        }
        
        // Draw hit effect
        ctx.fillStyle = '#FFFF00';
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#FF6600';
        ctx.beginPath();
        ctx.arc(projectile.x, projectile.y, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Remove projectile
        gameState.projectiles.splice(i, 1);
      }
      
      // Draw projectile while in flight
      if (distToTarget > 5) {
        const color = projectile.type === 'archer' ? '#8B4513' : 
                     projectile.type === 'cannon' ? '#696969' :
                     projectile.type === 'mage' ? '#9370DB' :
                     projectile.type === 'ice' ? '#87CEEB' :
                     projectile.type === 'poison' ? '#32CD32' :
                     projectile.type === 'lightning' ? '#FFFF00' :
                     projectile.type === 'shield' ? '#FFD700' :
                     projectile.type === 'fire' ? '#FF4500' : '#FFFFFF';
        
        // Fire tower projectiles are handled separately (continuous laser beam)
        // Skip drawing fire projectiles here since they're drawn as continuous beams
        if (projectile.type !== 'fire') {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(projectile.x, projectile.y, 4, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw projectile trail
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.moveTo(projectile.x - projectile.vx * 2, projectile.y - projectile.vy * 2);
          ctx.lineTo(projectile.x, projectile.y);
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }
      }
    }
  }
  
  // Spawn zombies in a line - one at a time with fixed spacing
  let maxZombies = gameState.maxZombiesThisWave || 5; // Use predetermined count for this wave
  
  // Initialize next spawn time if not set
  if (gameState.waveActive && gameState.nextZombieSpawnTime === 0 && gameState.zombiesSpawnedThisWave === 0) {
    gameState.nextZombieSpawnTime = Date.now() + 800; // First zombie spawns after 800ms
  }
  
  // Spawn zombies in a line with 800ms spacing between each zombie
  if (gameState.waveActive && 
      gameState.zombiesSpawnedThisWave < maxZombies && 
      Date.now() >= gameState.nextZombieSpawnTime) {
    spawnZombie();
    gameState.zombiesSpawnedThisWave++;
    // Schedule next zombie to spawn 800ms later
    gameState.nextZombieSpawnTime = Date.now() + 800;
  }
  
  // Check wave complete
  if (gameState.zombies.length === 0 && gameState.waveActive && gameState.zombieSpawnTime === 0) {
    gameState.waveActive = false;
    
    // Check for map completion BEFORE incrementing wave
    // Check if frozen pass is completed (beat Frozen Pass) - check this first
    if (gameState.wave === 20 && gameState.currentLevel === 'frozen') {
      gameState.desertMapUnlocked = true;
      gameState.zombieReachedBase = false;
      autoSave(); // Auto-save after unlocking map
      
      // Stop game immediately
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      showVictory('Frozen Pass');
      return; // Exit early - DO NOT continue
    }
    
    // Check if wave 20 is completed (beat Whispering Woods)
    if (gameState.wave === 20 && gameState.currentLevel !== 'frozen') {
      // Unlock Frozen Pass if not already unlocked
      if (!gameState.frozenMapUnlocked) {
        gameState.frozenMapUnlocked = true;
      }
      gameState.zombieReachedBase = false;
      autoSave(); // Auto-save after unlocking map
      
      // Stop game immediately
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      
      showVictory('Whispering Woods');
      return; // Exit early - DO NOT continue
    }
    
    // Only increment wave if not completing the map (wave 20 completed)
    gameState.wave++;
    gameState.zombieSpawnTime = 0;
    gameState.zombiesSpawnedThisWave = 0; // Reset zombie spawn counter for next wave
    gameState.nextZombieSpawnTime = 0; // Reset next spawn time for next wave
    gameState.bossSpawned = false; // Reset boss spawn status for next wave
    
    // Check wave-based quest completion after wave increments
    checkQuestCompletion('reachWave');

    // Safety: If somehow we passed wave 20 in Frozen, unlock Desert and return to menu
    if (gameState.currentLevel === 'frozen' && gameState.wave > 20) {
      gameState.desertMapUnlocked = true;
      gameState.zombieReachedBase = false;
        autoSave();
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
        showVictory('Frozen Pass');
      return;
    }
    // Check if desert map wave 20 is completed
    if (gameState.wave === 20 && gameState.currentLevel === 'desert') {
      gameState.zombieReachedBase = false;
      autoSave();
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      showVictory('Desert Oasis');
      return;
    }
    
    // Safety: If somehow we passed wave 20 in Woods, return to menu (no further waves)
    if (gameState.currentLevel !== 'frozen' && gameState.currentLevel !== 'desert' && gameState.wave > 20) {
      gameState.zombieReachedBase = false;
      autoSave();
      if (gameLoop) {
        clearInterval(gameLoop);
        gameLoop = null;
      }
      showVictory('Whispering Woods');
      return;
    }
    
    // Wave completion rewards (only if zombies didn't reach base)
    gameState.gold += 15; // 15 gold for completing wave
    gameState.shopGold += 15; // 15 gold for shop
    autoSave(); // Auto-save after earning rewards
    
    // Only give EXP and level up if no zombie reached the base
    if (!gameState.zombieReachedBase) {
      gameState.experience += 1; // 1 EXP per wave
      
      // Check for level up
      if (gameState.experience >= gameState.experienceToNext) {
        gameState.experience -= gameState.experienceToNext;
        gameState.playerLevel++;
        gameState.gamesPlayed++;
        
        // Progressive EXP requirements: 2, 3, 4, 5, 6, 7, 8, then cap at 8
        // For level 2: need 2 exp
        // For level 3: need 3 exp
        // For level 4: need 4 exp
        // For level 5: need 5 exp
        // For level 6: need 6 exp
        // For level 7: need 7 exp
        // For level 8+: need 8 exp (capped)
        gameState.experienceToNext = Math.min(8, 2 + gameState.playerLevel);
        
        checkLevelUnlocks();
        updateMainMenuUI();
        autoSave(); // Auto-save after leveling up
        alert(`Level up! You are now level ${gameState.playerLevel}!`);
      }
    }
    
    // Reset the flag for next wave
    gameState.zombieReachedBase = false;
    
    // Don't start countdown timer between waves - only at round start
    // Start next wave automatically after a short delay (2 seconds)
    if (gameState.wave <= 20 && gameState.autoWave) {
      setTimeout(() => {
        if (!gameState.waveActive && gameState.wave <= 20) {
          startWave();
        }
      }, 2000);
    }
    
    updateUI();
  }
  
  // Game over check moved to zombie reaching base
}

function getPositionAtProgress(progress) {
  const segment = Math.floor(progress);
  const t = progress - segment;
  if (segment >= path.length - 1) return {x: path[path.length-1].x, y: path[path.length-1].y};
  return {
    x: path[segment].x + (path[segment+1].x - path[segment].x) * t,
    y: path[segment].y + (path[segment+1].y - path[segment].y) * t
  };
}

document.addEventListener('DOMContentLoaded', () => {
  // Initialize game state
  console.log('Tower Defense Game Loaded');
  
  // Ensure only main menu is visible on load
  document.querySelectorAll('.screen').forEach(screen => {
    if (screen.id === 'mainMenu') {
      screen.classList.add('active');
      screen.style.display = 'flex';
    } else {
      screen.classList.remove('active');
      screen.style.display = 'none';
    }
  });
  
  // Clear any game-specific state (towers, zombies, etc.) on page load
  // This prevents showing towers when just viewing the menu
  gameState.towers = [];
  gameState.zombies = [];
  gameState.barriers = [];
  gameState.projectiles = [];
  gameState.wave = 1;
  gameState.waveActive = false;
  gameState.currentLevel = null;
  gameState.selectedTower = null;
  gameState.frameCount = 0;
  
  // IMPORTANT: Always disable test mode on page load
  gameState.testMode = false;
  gameState.gold = 200; // Reset to default starting gold
  gameState.countdownShownThisRound = false; // Reset countdown flag
  
  // Stop any running game loop
  if (gameLoop) {
    clearInterval(gameLoop);
    gameLoop = null;
  }
  
  // Load saved game state on page refresh
  const saved = localStorage.getItem('towerDefenseSave');
  if (saved) {
    try {
      const savedState = JSON.parse(saved);
      
      // Migrate old saves from towerInventory to unlockedTowers
      if (savedState.towerInventory && !savedState.unlockedTowers) {
        savedState.unlockedTowers = {
          archer: (savedState.towerInventory.archer || 0) > 0,
          cannon: (savedState.towerInventory.cannon || 0) > 0,
          mage: (savedState.towerInventory.mage || 0) > 0,
          ice: (savedState.towerInventory.ice || 0) > 0,
          poison: false,
          lightning: false,
          shield: false,
          fire: false
        };
        delete savedState.towerInventory;
      }
      
      // Restore progression data (but not active game state)
      const { testMode, towers, zombies, barriers, projectiles, wave, currentLevel, waveActive, ...progressionData } = savedState;
      gameState = {
        ...gameState,
        ...progressionData,
        testMode: false, // Always disable test mode
        gold: 200, // Reset to default starting gold
        towers: [],
        zombies: [],
        barriers: [],
        projectiles: [],
        wave: 1,
        waveActive: false,
        currentLevel: null
      };
      
      console.log('Game progress loaded from auto-save');
    } catch (e) {
      console.error('Error loading saved game:', e);
    }
  }
  
  // Update main menu UI with current gold
  updateMainMenuUI();
  
  // Check if admin username is set and enable admin mode
  if (gameState.playerName === 'pc_man950') {
    enableAdminMode();
  }
  
  // Initialize quest system
  if (!gameState.quests || gameState.quests.length === 0 || 
      (gameState.questRefreshTime && Date.now() >= gameState.questRefreshTime)) {
    generateQuests();
  }
  updateQuestsUI();
  
  // Update UI elements
  updateLevelSelectionUI();
  updateTowerVisibility();
  updateShopUI();
  
  // Test shop button
  const shopButton = document.querySelector('button[onclick*="shop"]');
  if (shopButton) {
    console.log('Shop button found:', shopButton);
  } else {
    console.error('Shop button not found!');
  }
});

function pointToLineDist(px, py, p1, p2) {
  const A = px - p1.x;
  const B = py - p1.y;
  const C = p2.x - p1.x;
  const D = p2.y - p1.y;
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  if (lenSq != 0) param = dot / lenSq;
  let xx, yy;
  if (param < 0) {
    xx = p1.x;
    yy = p1.y;
  } else if (param > 1) {
    xx = p2.x;
    yy = p2.y;
  } else {
    xx = p1.x + param * C;
    yy = p1.y + param * D;
  }
  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

function selectTower(type) {
  // Check if player has unlocked this tower type
  if (!gameState.unlockedTowers[type]) {
    alert(`You haven't unlocked ${type} towers yet! Buy one from the shop first.`);
    return;
  }
  
  gameState.selectedTower = {
    type,
    cost: type === 'archer' ? 100 : type === 'cannon' ? 150 : type === 'mage' ? 200 : type === 'ice' ? 200 : type === 'poison' ? 150 : type === 'lightning' ? 250 : type === 'shield' ? 300 : type === 'fire' ? 150 : 350,
    damage: type === 'archer' ? 10 : type === 'cannon' ? 30 : type === 'mage' ? 40 : type === 'ice' ? 35 : type === 'poison' ? 25 : type === 'lightning' ? 85 : type === 'fire' ? 250 : 15,
    range: type === 'archer' ? 150 : type === 'cannon' ? 100 : type === 'mage' ? 200 : type === 'ice' ? 120 : type === 'poison' ? 140 : type === 'lightning' ? 180 : type === 'fire' ? 200 : 200,
    color: type === 'archer' ? '#8B4513' : type === 'cannon' ? '#696969' : type === 'mage' ? '#9370DB' : type === 'ice' ? '#87CEEB' : type === 'poison' ? '#228B22' : type === 'lightning' ? '#4169E1' : type === 'fire' ? '#FF4500' : '#C0C0C0'
  };
  
  // Visual feedback - find the correct tower option element
  document.querySelectorAll('.tower-option').forEach(el => el.classList.remove('selected'));
  const towerElement = document.getElementById(type + 'TowerOption');
  if (towerElement) {
    towerElement.classList.add('selected');
  }
  
  alert(`Selected ${type} tower! Click on the map to place it.`);
}

function updateUI() {
  const goldEl = document.getElementById('goldDisplay');
  const livesEl = document.getElementById('livesDisplay');
  const waveEl = document.getElementById('waveDisplay');
  const killsEl = document.getElementById('killsDisplay');
  
  if (goldEl) {
    goldEl.textContent = gameState.testMode ? 'âˆž' : gameState.gold;
    // Make gold text white for Whispering Woods and Desert Oasis
    if (gameState.currentLevel === 'woods' || gameState.currentLevel === 'desert') {
      goldEl.style.color = '#ffffff';
    } else {
      goldEl.style.color = '';
    }
  }
  if (livesEl) {
    livesEl.textContent = gameState.lives;
    // Flash red when health is low
    if (gameState.lives <= 5) {
      livesEl.style.color = '#ff4444';
      livesEl.style.animation = 'pulse 0.5s infinite';
    } else {
      livesEl.style.color = '';
      livesEl.style.animation = '';
    }
  }
  if (waveEl) waveEl.textContent = `Wave: ${gameState.wave}/${gameState.maxWave}`;
  if (killsEl) killsEl.textContent = `Kills: ${gameState.zombiesKilled || 0}`;
}

function updateShopUI() {
  const shopGoldEl = document.getElementById('shopGoldDisplay');
  if (shopGoldEl) shopGoldEl.textContent = gameState.shopGold;
  
  const shopGemsEl = document.getElementById('shopGemsDisplay');
  if (shopGemsEl) shopGemsEl.textContent = gameState.gems || 0;
  
  // Update tower unlock status in inventory display
  if (gameState.unlockedTowers) {
    const archerEl = document.getElementById('archerCount');
    const cannonEl = document.getElementById('cannonCount');
    const mageEl = document.getElementById('mageCount');
    const iceEl = document.getElementById('iceCount');
    const poisonEl = document.getElementById('poisonCount');
    const lightningEl = document.getElementById('lightningCount');
    const shieldEl = document.getElementById('shieldCount');
    const fireEl = document.getElementById('fireCount');
    
    if (archerEl) archerEl.textContent = gameState.unlockedTowers.archer ? 'Unlocked' : 'Locked';
    if (cannonEl) cannonEl.textContent = gameState.unlockedTowers.cannon ? 'Unlocked' : 'Locked';
    if (mageEl) mageEl.textContent = gameState.unlockedTowers.mage ? 'Unlocked' : 'Locked';
    if (iceEl) iceEl.textContent = gameState.unlockedTowers.ice ? 'Unlocked' : 'Locked';
    if (poisonEl) poisonEl.textContent = gameState.unlockedTowers.poison ? 'Unlocked' : 'Locked';
    if (lightningEl) lightningEl.textContent = gameState.unlockedTowers.lightning ? 'Unlocked' : 'Locked';
    if (shieldEl) shieldEl.textContent = gameState.unlockedTowers.shield ? 'Unlocked' : 'Locked';
    if (fireEl) fireEl.textContent = gameState.unlockedTowers.fire ? 'Unlocked' : 'Locked';
  }
  
  // Map-based tower availability (fire tower can be unlocked at any arena)
  const mapRequirements = {
    archer: 'woods',
    cannon: 'woods',
    poison: 'woods',
    ice: 'frozen',
    fire: null, // Fire tower has no map requirement (can unlock at any arena)
    mage: 'frozen',
    shield: 'desert', // Support tower unlocks at Desert Oasis
    lightning: 'desert'
  };
  
  // Update shop cards to show unlocked status and hide unavailable towers
  const towerTypes = ['archer', 'cannon', 'mage', 'ice', 'poison', 'lightning', 'shield', 'fire'];
  towerTypes.forEach(type => {
    const cardEl = document.getElementById(`shop${type.charAt(0).toUpperCase() + type.slice(1)}Card`);
    const statusEl = document.getElementById(`shop${type.charAt(0).toUpperCase() + type.slice(1)}Status`);
    const requiredMap = mapRequirements[type];
    
    // Check if map is unlocked
    let mapUnlocked = false;
    if (requiredMap === null) {
      mapUnlocked = true; // Fire tower - always available (uses gems)
    } else if (requiredMap === 'woods') {
      mapUnlocked = true; // Always available
    } else if (requiredMap === 'frozen') {
      mapUnlocked = gameState.frozenMapUnlocked;
    } else if (requiredMap === 'desert') {
      mapUnlocked = gameState.desertMapUnlocked;
    }
    
    if (cardEl) {
      // Hide tower if map is not unlocked
      if (!mapUnlocked) {
        cardEl.style.display = 'none';
      } else {
        cardEl.style.display = 'flex';
        
        // Show unlocked status
        if (gameState.unlockedTowers[type]) {
          cardEl.style.opacity = '0.6';
          cardEl.style.cursor = 'not-allowed';
          cardEl.classList.remove('hover:border-primary');
          cardEl.classList.add('border-primary/50');
          if (statusEl) {
            statusEl.style.display = 'block';
          }
        } else {
          cardEl.style.opacity = '1';
          cardEl.style.cursor = 'pointer';
          cardEl.classList.add('hover:border-primary');
          cardEl.classList.remove('border-primary/50');
          if (statusEl) {
            statusEl.style.display = 'none';
          }
        }
      }
    }
  });
}

function buyTower(towerType) {
  // Check if tower is already unlocked
  if (gameState.unlockedTowers[towerType]) {
    alert(`${towerType.charAt(0).toUpperCase() + towerType.slice(1)} tower is already unlocked!`);
    return;
  }
  
  // Map-based tower unlocking (except fire tower which uses gems)
  const mapRequirements = {
    archer: 'woods',    // Whispering Woods
    cannon: 'woods',    // Whispering Woods
    poison: 'woods',    // Whispering Woods
    ice: 'frozen',      // Frozen Pass
    fire: null,         // Fire tower can be unlocked at any arena (uses gems)
    mage: 'frozen',     // Frozen Pass
    shield: 'desert',   // Desert Oasis - Support tower unlocks at Desert Oasis
    lightning: 'desert', // Desert Oasis
    // barrier is shield
  };
  
  const costs = {
    archer: 100,
    cannon: 1000,
    poison: 2000,
    ice: 3000,
    fire: 250, // Fire tower costs 250 gems (not shop gold)
    mage: 5000,
    shield: 7500,
    lightning: 10000
  };
  
  const requiredMap = mapRequirements[towerType];
  
  // Fire tower uses gems instead of shop gold and has no map requirement
  if (towerType === 'fire') {
    const cost = costs[towerType];
    if (gameState.gems >= cost) {
      gameState.gems -= cost;
      gameState.unlockedTowers[towerType] = true;
      
      // Automatically equip the tower if there's space (max 5 towers)
      if (!gameState.equippedTowers.includes(towerType) && gameState.equippedTowers.length < 5) {
        gameState.equippedTowers.push(towerType);
      }
      
      updateShopUI();
      updateQuestsUI(); // Update gems display
      updateInventoryScreenUI();
      updateTowerVisibility();
      autoSave();
      alert(`Unlocked ${towerType} tower for ${cost} gems! You can now purchase and place ${towerType} towers during gameplay using your in-game gold.`);
    } else {
      alert(`Not enough gems! You need ${cost} gems but only have ${gameState.gems}. Complete quests to earn more gems!`);
    }
    return;
  }
  
  // Check if required map is unlocked (for non-fire towers)
  if (requiredMap === 'frozen' && !gameState.frozenMapUnlocked) {
    alert(`You need to unlock the Frozen Pass map first to unlock ${towerType} towers!`);
    return;
  }
  
  if (requiredMap === 'desert' && !gameState.desertMapUnlocked) {
    alert(`You need to unlock the Desert Oasis map first to unlock ${towerType} towers!`);
    return;
  }
  
  const cost = costs[towerType];
  
  if (gameState.shopGold >= cost) {
    gameState.shopGold -= cost;
    gameState.unlockedTowers[towerType] = true; // Unlock the tower type (makes it available to purchase in-game)
    
    // Automatically equip the tower if there's space (max 5 towers)
    if (!gameState.equippedTowers.includes(towerType) && gameState.equippedTowers.length < 5) {
      gameState.equippedTowers.push(towerType);
    }
    
    updateShopUI();
    updateInventoryScreenUI(); // Update inventory to show new equipment status
    updateTowerVisibility(); // Update tower visibility in game
    autoSave(); // Auto-save after unlocking tower
    alert(`Unlocked ${towerType} tower! You can now purchase and place ${towerType} towers during gameplay using your in-game gold.`);
  } else {
    alert(`Not enough shop gold! You need ${cost} gold but only have ${gameState.shopGold}. Complete waves to earn more shop gold!`);
  }
}

function showGameOver() {
  // Update game over screen stats
  const waveEl = document.getElementById('gameOverWave');
  const killsEl = document.getElementById('gameOverKills');
  const goldEl = document.getElementById('gameOverGold');
  
  if (waveEl) waveEl.textContent = gameState.wave;
  if (killsEl) {
    const killsTotal = Number(gameState.zombiesKilled) || 0;
    killsEl.textContent = killsTotal;
  }
  if (goldEl) goldEl.textContent = gameState.testMode ? 'âˆž' : gameState.gold;
  
  resetGameState(); // Reset game state but keep progression
  setTimeout(() => goToScreen('gameOver'), 500);
}

function showVictory(levelName) {
  // Check if Desert Oasis was completed (final map - game beaten)
  if (levelName === 'Desert Oasis') {
    resetGameState(); // Reset game state but keep progression
    
    // Update main menu UI
    updateMainMenuUI();
    
    // Show victory message and return to main menu
    alert('ðŸŽ‰ You beat the game! ðŸŽ‰\n\nCongratulations on completing all maps!');
    goToScreen('mainMenu');
    return;
  }
  
  // Update victory screen stats for other maps
  const levelEl = document.getElementById('victoryLevel');
  const wavesEl = document.getElementById('victoryWaves');
  const killsEl = document.getElementById('victoryKills');
  const towersEl = document.getElementById('victoryTowers');
  const goldEl = document.getElementById('victoryGold');
  
  if (levelEl) levelEl.textContent = levelName;
  if (wavesEl) wavesEl.textContent = `${gameState.wave}/20`;
  if (killsEl) {
    const killsTotal = Number(gameState.zombiesKilled) || 0;
    killsEl.textContent = killsTotal;
  }
  if (towersEl) {
    const towersPlacedTotal = Number(gameState.towersPlaced) || 0;
    towersEl.textContent = towersPlacedTotal;
  }
  if (goldEl) goldEl.textContent = gameState.testMode ? 'âˆž' : gameState.gold;
  
  resetGameState(); // Reset game state but keep progression
  
  // Update main menu UI (to show reset button if desert map was beaten)
  updateMainMenuUI();
  
  setTimeout(() => goToScreen('victory'), 500);
}

function resetAllProgress() {
  if (!confirm('Are you sure you want to reset ALL progress? This will delete everything: levels, towers, gold, maps, etc. This cannot be undone!')) {
    return;
  }
  
  // Reset all game state
  gameState.playerLevel = 1;
  gameState.experience = 0;
  gameState.experienceToNext = 2;
  gameState.unlockedTowers = {
    archer: true,
    cannon: false,
    mage: false,
    ice: false,
    poison: false,
    lightning: false,
    shield: false,
    fire: false
  };
  gameState.frozenMapUnlocked = false;
  gameState.desertMapUnlocked = false;
  gameState.shopGold = 100;
  gameState.gold = 200;
  
  // Clear saved data
  localStorage.removeItem('towerDefenseSave');
  
  // Update UI
  updateMainMenuUI();
  updateShopUI();
  updateInventoryScreenUI();
  updateLevelSelectionUI();
  alert('All progress has been reset!');
}

function resetGameState() {
  // Reset game-specific values but preserve progression
  gameState.lives = 3; // Reset to 3 lives
  // Preserve unlimited gold in test mode, otherwise reset to starting gold
  if (!gameState.testMode) {
    gameState.gold = 300; // Reset to starting gold
  } else {
    gameState.gold = 999999; // Maintain unlimited gold in test mode
  }
  gameState.wave = 1; // Reset to wave 1
  gameState.zombies = []; // Clear zombies
  gameState.towers = []; // Clear towers
  gameState.barriers = []; // Clear barriers
  gameState.projectiles = []; // Clear projectiles
  gameState.selectedTower = null; // Clear selection
  gameState.currentLevel = null; // Clear selected level
  gameState.zombieReachedBase = false; // Reset zombie base flag
  gameState.zombieSpawnTime = 0; // Reset spawn timer
  gameState.waveActive = false; // Stop wave
  gameState.frameCount = 0; // Reset frame counter
  gameState.bossSpawned = false; // Reset boss spawn status
  gameState.gamePaused = false; // Reset pause state
  gameState.fastForward = false; // Reset fast forward
  gameState.gameSpeed = 1.0; // Reset speed
  gameState.zombiesKilled = 0; // Reset kill counter
  gameState.towersPlaced = 0; // Reset tower counter
  gameState.selectedTowerForUpgrade = null; // Clear upgrade selection
  gameState.poisonClouds = []; // Clear poison clouds
  gameState.archerAbilityCooldownUntil = null; // Reset ability cooldown
  gameState.cannonAbilityCooldownUntil = null; // Reset cannon ability cooldown
  gameState.fireAbilityCooldownUntil = null; // Reset fire ability cooldown
  gameState.supportWallCooldownUntil = null; // Reset support wall ability cooldown
  gameState.supportHealCooldownUntil = null; // Reset support heal ability cooldown
  gameState.allTowersBoostUntil = null; // Reset global combat boost
  gameState.supportBoostCooldownUntil = null; // Reset support boost ability cooldown
  
  // Close upgrade panel
  closeUpgradePanel();
  
  // Keep progression: playerLevel, experience, unlockedTowers, shopGold, frozenMapUnlocked, desertMapUnlocked
  console.log('Game state reset - Lives:', gameState.lives, 'Gold:', gameState.gold);
  
  // Update UI to reflect the reset values
  updateUI();
  updateMainMenuUI();
  updateLevelSelectionUI();
  updateTowerVisibility(); // Update tower visibility after reset
  
  // Ensure wave button is visible after reset
  const waveButton = document.getElementById('waveButton');
  if (waveButton) {
    waveButton.style.display = 'block';
    waveButton.textContent = `Start Wave ${gameState.wave}`;
  }
}

function saveGame() {
  // IMPORTANT: Always save testMode as false - don't persist it
  const stateToSave = { ...gameState, testMode: false };
  localStorage.setItem('towerDefenseSave', JSON.stringify(stateToSave));
  alert('Game saved!');
}

function autoSave() {
  // Auto-save progress (without test mode)
  const stateToSave = { ...gameState, testMode: false };
  localStorage.setItem('towerDefenseSave', JSON.stringify(stateToSave));
}

function loadGame() {
  const saved = localStorage.getItem('towerDefenseSave');
  if (saved) {
    try {
    const savedState = JSON.parse(saved);
    
    // Migrate old saves from towerInventory to unlockedTowers
    if (savedState.towerInventory && !savedState.unlockedTowers) {
      savedState.unlockedTowers = {
        archer: (savedState.towerInventory.archer || 0) > 0,
        cannon: (savedState.towerInventory.cannon || 0) > 0,
        mage: (savedState.towerInventory.mage || 0) > 0,
        ice: (savedState.towerInventory.ice || 0) > 0,
        poison: false,
        lightning: false,
        shield: false,
        fire: false
      };
      delete savedState.towerInventory; // Remove old property
    }
    
    // Set defaults for new progression system
    if (!savedState.playerLevel) savedState.playerLevel = 1;
    if (!savedState.gamesPlayed) savedState.gamesPlayed = 0;
    if (!savedState.experience) savedState.experience = 0;
    if (!savedState.experienceToNext) savedState.experienceToNext = 2;
    if (!savedState.unlockedTowers) {
      savedState.unlockedTowers = {archer: true, cannon: false, mage: false, ice: false, poison: false, lightning: false, shield: false, fire: false};
    }
    if (!savedState.frozenMapUnlocked) savedState.frozenMapUnlocked = false;
    if (!savedState.desertMapUnlocked) savedState.desertMapUnlocked = false;
    if (!savedState.shopGold) savedState.shopGold = 100;
      if (savedState.bossSpawned === undefined) savedState.bossSpawned = false;
      if (savedState.soundEnabled === undefined) savedState.soundEnabled = true;
      if (savedState.musicEnabled === undefined) savedState.musicEnabled = true;
      if (savedState.notificationsEnabled === undefined) savedState.notificationsEnabled = false;
      
      // Check if there's an active game in progress (has towers, wave > 1, or currentLevel set)
      const hasActiveGame = (savedState.towers && savedState.towers.length > 0) || 
                           (savedState.wave && savedState.wave > 1) || 
                           (savedState.currentLevel && savedState.currentLevel !== null);
      
      if (hasActiveGame) {
        // Restore the full game state including in-game progress
        // Preserve defaults for game-specific states that might not be saved
        // IMPORTANT: DO NOT restore testMode - it should always be disabled
        const restoredGold = savedState.gold !== undefined ? savedState.gold : 300;
        
        // Check if test mode was previously enabled - if so, reset unlockedTowers and maps
        const wasTestMode = savedState.testMode === true;
        const defaultUnlockedTowers = {archer: true, cannon: false, mage: false, ice: false, poison: false, lightning: false, shield: false, fire: false};
        
        gameState = {
          gold: restoredGold,
          testMode: false, // Always disable test mode - don't restore it
          lives: savedState.lives !== undefined ? Math.min(savedState.lives, 10) : 3, // Cap at 10 lives maximum
          wave: 1, // Always reset to wave 1 when loading - start fresh
          maxWave: savedState.maxWave || 20,
          zombies: [], // Clear zombies - they shouldn't be restored
          towers: savedState.towers || [],
          barriers: savedState.barriers || [],
          projectiles: [], // Clear projectiles - they shouldn't be restored
          selectedTower: savedState.selectedTower || null,
          currentLevel: savedState.currentLevel || null,
          zombieSpawnTime: 0, // Reset spawn timer
          waveActive: false, // Reset wave active state - player needs to start wave again
          zombieReachedBase: false, // Reset flag
          frameCount: 0, // Reset frame counter
          autoWave: true, // Always auto-start waves
          soundEnabled: savedState.soundEnabled !== undefined ? savedState.soundEnabled : true,
          musicEnabled: savedState.musicEnabled !== undefined ? savedState.musicEnabled : true,
          notificationsEnabled: savedState.notificationsEnabled || false,
          maxZombiesThisWave: 5, // Reset to default - will be set when wave starts
          zombiesSpawnedThisWave: 0, // Reset zombie spawn counter
          nextZombieSpawnTime: 0, // Reset next spawn time
          playerLevel: savedState.playerLevel || 1,
          gamesPlayed: savedState.gamesPlayed || 0,
          experience: savedState.experience || 0,
          experienceToNext: savedState.experienceToNext || 2,
          unlockedTowers: wasTestMode ? defaultUnlockedTowers : (savedState.unlockedTowers || defaultUnlockedTowers),
          equippedTowers: savedState.equippedTowers && Array.isArray(savedState.equippedTowers) ? savedState.equippedTowers : (wasTestMode ? ['archer'] : (savedState.unlockedTowers && savedState.unlockedTowers.archer ? ['archer'] : [])),
          frozenMapUnlocked: wasTestMode ? false : (savedState.frozenMapUnlocked || false),
          desertMapUnlocked: wasTestMode ? false : (savedState.desertMapUnlocked || false),
          shopGold: savedState.shopGold || 100,
          bossSpawned: false, // Reset boss spawn - will spawn again when wave starts
          gamePaused: false, // Reset pause state
          fastForward: false, // Reset fast forward
          gameSpeed: 1.0, // Reset speed
          zombiesKilled: (savedState.zombiesKilled !== undefined && savedState.zombiesKilled !== null) ? savedState.zombiesKilled : 0,
          towersPlaced: (savedState.towersPlaced !== undefined && savedState.towersPlaced !== null) ? savedState.towersPlaced : 0,
          selectedTowerForUpgrade: null,
          poisonClouds: [], // Clear poison clouds
          desertDecor: [], // Clear desert decorations
          sandstorm: null, // Clear sandstorm
          countdownTimer: 0, // Reset countdown timer
          countdownInterval: null, // Clear countdown interval
          countdownShownThisRound: false, // Reset countdown flag
          allTowersBoostUntil: null, // Reset global combat boost
          supportBoostCooldownUntil: null, // Reset support boost ability cooldown
          supportWallCooldownUntil: null, // Reset support wall ability cooldown
          supportHealCooldownUntil: null, // Reset support heal ability cooldown
          archerAbilityCooldownUntil: null, // Reset ability cooldowns when loading
          cannonAbilityCooldownUntil: null, // Reset cannon ability cooldown
          fireAbilityCooldownUntil: null, // Reset fire ability cooldown
        };
        
        // Restore path based on current level
        if (gameState.currentLevel === 'frozen') {
          path = [
            {x: 0, y: 250},
            {x: 150, y: 250},
            {x: 150, y: 350},
            {x: 300, y: 350},
            {x: 300, y: 150},
            {x: 450, y: 150},
            {x: 450, y: 300},
            {x: 600, y: 300},
            {x: 600, y: 100},
            {x: 750, y: 100},
            {x: 750, y: 400},
            {x: 800, y: 400}
          ];
        } else if (gameState.currentLevel === 'desert') {
          path = [
            {x: 0, y: 100},
            {x: 100, y: 100},
            {x: 100, y: 300},
            {x: 250, y: 300},
            {x: 250, y: 150},
            {x: 400, y: 150},
            {x: 400, y: 400},
            {x: 550, y: 400},
            {x: 550, y: 200},
            {x: 700, y: 200},
            {x: 700, y: 350},
            {x: 800, y: 350}
          ];
        } else {
          // Default woods map path
          path = [
            {x: 0, y: 300},
            {x: 200, y: 300},
            {x: 200, y: 150},
            {x: 400, y: 150},
            {x: 400, y: 350},
            {x: 600, y: 350},
            {x: 600, y: 200},
            {x: 800, y: 200}
          ];
        }
        
        // Update UI
        updateUI();
        updateMainMenuUI();
        updateLevelSelectionUI();
        updateTowerVisibility();
        
        // Update pause/fast forward button states
        const pauseBtn = document.getElementById('pauseBtn');
        if (pauseBtn) {
          const icon = pauseBtn.querySelector('.material-symbols-outlined');
          if (icon) {
            icon.textContent = gameState.gamePaused ? 'play_arrow' : 'pause';
          }
        }
        
        const fastForwardBtn = document.getElementById('fastForwardBtn');
        if (fastForwardBtn) {
          if (gameState.fastForward) {
            fastForwardBtn.classList.add('bg-primary/50');
          } else {
            fastForwardBtn.classList.remove('bg-primary/50');
          }
        }
        
        // Initialize game properly
        initGame();
        
        // Go directly to the game
        goToScreen('inGame');
        
        // Update wave button text
        const waveButton = document.getElementById('waveButton');
        if (waveButton) {
          if (gameState.autoWave) {
            waveButton.style.display = 'none';
          } else {
            waveButton.style.display = 'block';
            waveButton.textContent = `Start Wave ${gameState.wave}`;
          }
        }
        
        alert(`Game loaded! You're on Wave ${gameState.wave} with ${gameState.towers.length} towers placed. The game will start automatically.`);
      } else {
        // No active game, just restore progression and go to level selection
        // DO NOT restore testMode - explicitly exclude it
        const { testMode, ...progressionData } = savedState;
        gameState = {...gameState, ...progressionData};
        // IMPORTANT: Always disable test mode - don't restore it
        gameState.testMode = false;
        gameState.gold = 200; // Reset to default starting gold
        
        // Check if test mode was previously enabled - if so, reset unlockedTowers and maps
        const wasTestMode = savedState.testMode === true;
        if (wasTestMode) {
          // Reset to default: only archer unlocked
          gameState.unlockedTowers = {
            archer: true,
            cannon: false,
            mage: false,
            ice: false,
            poison: false,
            lightning: false,
            shield: false,
            fire: false
          };
          // Reset maps
          gameState.frozenMapUnlocked = false;
          gameState.desertMapUnlocked = false;
        }
        
        updateMainMenuUI();
        updateLevelSelectionUI();
        updateTowerVisibility();
        goToScreen('levelSelection');
        alert('Progress loaded! Select a level to start playing.');
      }
    } catch (e) {
      console.error('Error loading game:', e);
      alert('Error loading saved game. Starting fresh.');
      goToScreen('levelSelection');
    }
  } else {
    alert('No saved game found! Starting new game.');
    goToScreen('levelSelection');
  }
}

// Settings screen
function openPlayerProfile() {
  // Show player profile information with option to change name
  const currentName = gameState.playerName || 'Player123';
  const newName = prompt(
    `Player Profile\n\n` +
    `Current Name: ${currentName}\n` +
    `Level: ${gameState.playerLevel}\n` +
    `Experience: ${gameState.experience}/${gameState.experienceToNext}\n` +
    `Games Played: ${gameState.gamesPlayed}\n` +
    `Shop Gold: ${gameState.shopGold}\n\n` +
    `Maps Unlocked:\n` +
    `${gameState.frozenMapUnlocked ? 'âœ“' : 'âœ—'} Frozen Pass\n` +
    `${gameState.desertMapUnlocked ? 'âœ“' : 'âœ—'} Desert Oasis\n\n` +
    `Towers Unlocked:\n` +
    `${gameState.unlockedTowers.archer ? 'âœ“' : 'âœ—'} Archer\n` +
    `${gameState.unlockedTowers.cannon ? 'âœ“' : 'âœ—'} Cannon\n` +
    `${gameState.unlockedTowers.poison ? 'âœ“' : 'âœ—'} Poison\n` +
    `${gameState.unlockedTowers.ice ? 'âœ“' : 'âœ—'} Ice\n` +
    `${gameState.unlockedTowers.fire ? 'âœ“' : 'âœ—'} Fire\n` +
    `${gameState.unlockedTowers.mage ? 'âœ“' : 'âœ—'} Mage\n` +
    `${gameState.unlockedTowers.lightning ? 'âœ“' : 'âœ—'} Lightning\n` +
    `${gameState.unlockedTowers.shield ? 'âœ“' : 'âœ—'} Support\n\n` +
    `Enter new player name (or cancel to keep current):`,
    currentName
  );
  
  // Update player name if a new name was entered
  if (newName !== null && newName.trim() !== '') {
    const trimmedName = newName.trim();
    gameState.playerName = trimmedName;
    updatePlayerNameDisplay();
    
    // Check if admin username is entered
    if (trimmedName === 'pc_man950') {
      enableAdminMode();
    }
    
    autoSave(); // Save the new name
  }
}

function updatePlayerNameDisplay() {
  const playerNameEl = document.getElementById('playerNameDisplay');
  if (playerNameEl) {
    playerNameEl.textContent = gameState.playerName || 'Player123';
  }
}

function openSettings() {
  goToScreen('settings');
}

// Community, Leaderboard, Rewards
function openCommunity() {
  goToScreen('community');
}

function openQuests() {
  goToScreen('quests');
}

function openRewards() {
  goToScreen('rewards');
}

// Quest System
function refreshQuests() {
  const refreshCost = 200;
  
  if (gameState.shopGold < refreshCost) {
    alert(`Not enough shop gold! You need ${refreshCost} gold but only have ${gameState.shopGold}. Complete waves to earn more shop gold!`);
    return;
  }
  
  // Deduct cost
  gameState.shopGold -= refreshCost;
  
  // Reset quest progress for new quests
  gameState.questProgress = {};
  
  // Reset refresh timer (set to 5 minutes from now)
  gameState.questRefreshTime = Date.now() + (5 * 60 * 1000);
  
  // Generate new quests immediately
  generateQuests();
  
  // Update UI
  updateShopUI();
  updateQuestsUI();
  
  alert(`Quests refreshed! New quests are now available.`);
}

function generateQuests() {
  const questTypes = [
    { type: 'killBoss', name: 'Defeat a Boss', description: 'Kill 1 boss', target: 1, reward: 10 }, // Easy - 10 gems
    { type: 'killZombies', name: 'Zombie Slayer', description: 'Kill 50 zombies', target: 50, reward: 10 }, // Easy - 10 gems
    { type: 'reachWave', name: 'Wave Master', description: 'Reach wave 10', target: 10, reward: 10 }, // Easy - 10 gems
    { type: 'placeTowers', name: 'Tower Builder', description: 'Place 10 towers', target: 10, reward: 10 }, // Easy - 10 gems
    { type: 'killArmored', name: 'Armor Breaker', description: 'Kill 20 armored zombies', target: 20, reward: 15 }, // Hard - 15 gems
    { type: 'reachWave15', name: 'Survivor', description: 'Reach wave 15', target: 15, reward: 15 }, // Hard - 15 gems
    { type: 'kill100', name: 'Mass Killer', description: 'Kill 100 zombies', target: 100, reward: 15 } // Hard - 15 gems
  ];
  
  // Randomly select 3 unique quests
  const selectedQuests = [];
  const shuffled = questTypes.sort(() => Math.random() - 0.5);
  
  for (let i = 0; i < 3 && i < shuffled.length; i++) {
    const quest = shuffled[i];
    selectedQuests.push({
      id: Date.now() + i,
      type: quest.type,
      name: quest.name,
      description: quest.description,
      target: quest.target,
      progress: gameState.questProgress[quest.type] || 0,
      completed: false,
      claimed: false,
      reward: quest.reward // Use the reward from quest definition (10 or 15 gems)
    });
  }
  
  gameState.quests = selectedQuests;
  gameState.questRefreshTime = Date.now() + (5 * 60 * 1000); // 5 minutes from now
  
  updateQuestsUI();
}

function checkQuestCompletion(questType) {
  if (!gameState.quests || gameState.quests.length === 0) return;
  
  // Update progress based on quest type
  if (questType === 'killBoss') {
    gameState.questProgress.killBoss = (gameState.questProgress.killBoss || 0) + 1;
  } else if (questType === 'killZombies') {
    gameState.questProgress.killZombies = (gameState.questProgress.killZombies || 0) + 1;
  } else if (questType === 'killArmored') {
    gameState.questProgress.killArmored = (gameState.questProgress.killArmored || 0) + 1;
  }
  
  // Check each quest for completion
  gameState.quests.forEach(quest => {
    if (quest.completed || quest.claimed) return;
    
    let currentProgress = 0;
    
    if (quest.type === 'killBoss') {
      currentProgress = gameState.questProgress.killBoss || 0;
    } else if (quest.type === 'killZombies' || quest.type === 'kill100') {
      currentProgress = gameState.zombiesKilled || 0;
    } else if (quest.type === 'killArmored') {
      currentProgress = gameState.questProgress.killArmored || 0;
    } else if (quest.type === 'reachWave' || quest.type === 'reachWave15') {
      currentProgress = gameState.wave || 0;
    } else if (quest.type === 'placeTowers') {
      currentProgress = gameState.towersPlaced || 0;
    }
    
    quest.progress = currentProgress;
    
    if (currentProgress >= quest.target && !quest.completed) {
      quest.completed = true;
      // Don't auto-award gems - user must claim them
      updateQuestsUI();
    }
  });
  
  updateQuestsUI();
}

function claimQuest(questId) {
  if (!gameState.quests || gameState.quests.length === 0) return;
  
  const quest = gameState.quests.find(q => q.id === questId);
  if (!quest) return;
  
  if (!quest.completed) {
    alert('Quest is not completed yet!');
    return;
  }
  
  if (quest.claimed) {
    alert('Quest rewards have already been claimed!');
    return;
  }
  
  // Award gems
  quest.claimed = true;
  gameState.gems = (gameState.gems || 0) + quest.reward;
  
  // Update UI
  updateQuestsUI();
  updateShopUI();
  
  alert(`Quest Claimed: ${quest.name}\nReward: ${quest.reward} gems!`);
}

function updateQuestsUI() {
  const gemsEl = document.getElementById('gemsDisplay');
  if (gemsEl) gemsEl.textContent = gameState.gems || 0;
  
  const questListEl = document.getElementById('questList');
  const refreshTimerEl = document.getElementById('questRefreshTimer');
  
  if (!questListEl) return;
  
  // Update refresh timer
  if (refreshTimerEl && gameState.questRefreshTime) {
    const timeLeft = Math.max(0, gameState.questRefreshTime - Date.now());
    const minutes = Math.floor(timeLeft / 60000);
    const seconds = Math.floor((timeLeft % 60000) / 1000);
    refreshTimerEl.textContent = `Next refresh: ${minutes}:${seconds.toString().padStart(2, '0')}`;
  }
  
  // Generate quests if empty or refresh time passed
  if (!gameState.quests || gameState.quests.length === 0 || 
      (gameState.questRefreshTime && Date.now() >= gameState.questRefreshTime)) {
    generateQuests();
  }
  
  // Render quests
  if (gameState.quests && gameState.quests.length > 0) {
    questListEl.innerHTML = gameState.quests.map(quest => {
      const progressPercent = Math.min(100, (quest.progress / quest.target) * 100);
      const isCompleted = quest.completed;
      const isClaimed = quest.claimed;
      
      return `
        <div class="p-4 bg-white/5 rounded-lg border ${isCompleted && !isClaimed ? 'border-green-500/50' : isClaimed ? 'border-gray-500/50' : 'border-white/10'}">
          <div class="flex items-center justify-between mb-2">
            <h3 class="text-white font-bold ${isClaimed ? 'line-through text-gray-400' : ''}">${quest.name}</h3>
            <div class="flex items-center gap-1">
              <span class="material-symbols-outlined text-yellow-400 text-lg">diamond</span>
              <span class="text-yellow-400 font-bold">${quest.reward}</span>
            </div>
          </div>
          <p class="text-gray-400 text-sm mb-2">${quest.description}</p>
          <div class="flex items-center gap-2">
            <div class="flex-1 bg-white/10 rounded-full h-2 overflow-hidden">
              <div class="bg-primary h-full transition-all duration-300" style="width: ${progressPercent}%"></div>
            </div>
            <span class="text-white text-xs font-medium">${quest.progress}/${quest.target}</span>
          </div>
          ${isCompleted && !isClaimed ? `
            <button onclick="claimQuest(${quest.id})" class="mt-2 w-full bg-primary text-white py-2 rounded-lg font-bold hover:bg-primary/90 transition-colors">
              Claim ${quest.reward} Gems
            </button>
          ` : isClaimed ? '<p class="text-gray-400 text-xs mt-2">âœ“ Claimed</p>' : ''}
        </div>
      `;
    }).join('');
  }
}

// Check quest progress periodically
setInterval(() => {
  if (gameState.quests && gameState.quests.length > 0) {
    // Update all quest progress
    gameState.quests.forEach(quest => {
      if (quest.completed || quest.claimed) return;
      
      let currentProgress = 0;
      
      if (quest.type === 'killBoss') {
        currentProgress = gameState.questProgress.killBoss || 0;
      } else if (quest.type === 'killZombies' || quest.type === 'kill100') {
        currentProgress = gameState.zombiesKilled || 0;
      } else if (quest.type === 'killArmored') {
        currentProgress = gameState.questProgress.killArmored || 0;
      } else if (quest.type === 'reachWave' || quest.type === 'reachWave15') {
        currentProgress = gameState.wave || 0;
      } else if (quest.type === 'placeTowers') {
        currentProgress = gameState.towersPlaced || 0;
      }
      
      quest.progress = currentProgress;
      
      // Check if quest is completed
      if (currentProgress >= quest.target && !quest.completed) {
        quest.completed = true;
      }
    });
    
    // Check if refresh time has passed
    if (gameState.questRefreshTime && Date.now() >= gameState.questRefreshTime) {
      generateQuests();
    }
    
    updateQuestsUI();
  }
}, 1000); // Check every second

function enableTestMode() {
  // Unlock all towers
  gameState.unlockedTowers = {
    archer: true,
    cannon: true,
    mage: true,
    ice: true,
    poison: true,
    lightning: true,
    shield: true,
    fire: true
  };
  
  // Unlock all maps
  gameState.frozenMapUnlocked = true;
  gameState.desertMapUnlocked = true;
  
  // Enable test mode flag
  gameState.testMode = true;
  
  // Set unlimited coins (999999 gold)
  gameState.gold = 999999;
  
  // Update UI
  updateTowerVisibility();
  updateShopUI();
  updateMainMenuUI();
  updateLevelSelectionUI();
  updateUI(); // Update in-game UI if in game
  
  // Auto-save
  autoSave();
  
  alert('ðŸ§ª Test Mode Enabled!\n\nAll towers unlocked!\nAll maps unlocked!\nUnlimited coins!');
}

function enableAdminMode() {
  // Unlock all towers
  gameState.unlockedTowers = {
    archer: true,
    cannon: true,
    mage: true,
    ice: true,
    poison: true,
    lightning: true,
    shield: true,
    fire: true
  };
  
  // Unlock all maps
  gameState.frozenMapUnlocked = true;
  gameState.desertMapUnlocked = true;
  
  // Enable test mode flag (admin mode uses test mode functionality)
  gameState.testMode = true;
  
  // Set unlimited coins (999999 gold)
  gameState.gold = 999999;
  
  // Update UI
  updateTowerVisibility();
  updateShopUI();
  updateMainMenuUI();
  updateLevelSelectionUI();
  updateUI(); // Update in-game UI if in game
  
  // Auto-save
  autoSave();
  
  alert('ðŸ”‘ Admin Panel Activated!\n\nAll towers unlocked!\nAll maps unlocked!\nUnlimited coins!');
}

// Inventory functions
function toggleInventory() {
  const panel = document.getElementById('inventoryPanel');
  if (panel.style.display === 'none') {
    panel.style.display = 'block';
    updateInventoryScreenUI();
  } else {
    panel.style.display = 'none';
  }
}

function equipTower(towerType) {
  if (gameState.unlockedTowers[towerType]) {
    selectTower(towerType);
    toggleInventory(); // Close inventory after equipping
    alert(`${towerType} tower equipped! Click on the map to place it.`);
  } else {
    alert(`You haven't unlocked ${towerType} towers yet! Buy one from the shop first.`);
  }
}

function toggleEquipTower(towerType) {
  if (!gameState.unlockedTowers[towerType]) {
    alert(`You haven't unlocked ${towerType} towers yet! Buy one from the shop first.`);
    return;
  }
  
  const isEquipped = gameState.equippedTowers.includes(towerType);
  
  if (isEquipped) {
    // Unequip the tower
    gameState.equippedTowers = gameState.equippedTowers.filter(t => t !== towerType);
    updateInventoryScreenUI();
    updateTowerVisibility();
  } else {
    // Equip the tower (max 5)
    if (gameState.equippedTowers.length >= 5) {
      alert('You can only equip up to 5 towers at a time! Unequip one first.');
      return;
    }
    gameState.equippedTowers.push(towerType);
    updateInventoryScreenUI();
    updateTowerVisibility();
  }
}

function updateTowerVisibility() {
  // Hide all tower options first
  document.getElementById('archerTowerOption').style.display = 'none';
  document.getElementById('cannonTowerOption').style.display = 'none';
  document.getElementById('mageTowerOption').style.display = 'none';
  document.getElementById('iceTowerOption').style.display = 'none';
  document.getElementById('poisonTowerOption').style.display = 'none';
  document.getElementById('lightningTowerOption').style.display = 'none';
  document.getElementById('shieldTowerOption').style.display = 'none';
  document.getElementById('fireTowerOption').style.display = 'none';
  
  // Show only towers that are equipped (from loadout)
  gameState.equippedTowers.forEach(towerType => {
    const towerMap = {
      archer: 'archerTowerOption',
      cannon: 'cannonTowerOption',
      mage: 'mageTowerOption',
      ice: 'iceTowerOption',
      poison: 'poisonTowerOption',
      lightning: 'lightningTowerOption',
      shield: 'shieldTowerOption',
      fire: 'fireTowerOption'
    };
    const towerEl = document.getElementById(towerMap[towerType]);
    if (towerEl) {
      towerEl.style.display = 'flex';
    }
  });
}

function updateMainMenuUI() {
  const mainMenuGoldEl = document.getElementById('mainMenuGoldDisplay');
  if (mainMenuGoldEl) mainMenuGoldEl.textContent = gameState.testMode ? 'âˆž' : gameState.gold;
  
  // Update rebirth button visibility and count
  const resetBtn = document.getElementById('mainMenuResetButton');
  
  if (resetBtn) {
    // Show reset button if desert map has been beaten
    if (gameState.desertMapUnlocked) {
      resetBtn.style.display = 'flex';
    } else {
      resetBtn.style.display = 'none';
    }
  }
  
  // Update player name display
  updatePlayerNameDisplay();
  
  const playerLevelEl = document.getElementById('playerLevelDisplay');
  if (playerLevelEl) playerLevelEl.textContent = `Level ${gameState.playerLevel}`;
  
  // Update experience bar
  const experienceBarEl = document.getElementById('experienceBar');
  const experienceTextEl = document.getElementById('experienceText');
  if (experienceBarEl && experienceTextEl) {
    const expPercentage = (gameState.experience / gameState.experienceToNext) * 100;
    experienceBarEl.style.width = `${expPercentage}%`;
    experienceTextEl.textContent = `${gameState.experience}/${gameState.experienceToNext} EXP`;
  }
  
  // Update player icon based on level
  const playerIconEl = document.getElementById('playerIcon') || document.querySelector('.bg-center.bg-no-repeat.aspect-square.bg-cover.rounded-full.size-10');
  if (playerIconEl) {
    const iconUrls = {
      1: 'https://lh3.googleusercontent.com/aida-public/AB6AXuCIGp3UYF8LdNpijORgAxp349l_bu9hy38_JOoJoqFzWGD3xg5ZdVYIV1x2L4942Wdbin2LLP3zomOedC70Nv93K70y9wgjvNOuJrBOG78kHgg8uwQKpZj2FCz4H0X40HNhMwCVmlgzdHVVx4pA20Z4MOrcTkiY0Aq5yi5wSYbekuDFkCSZ-r-f4-3IyRjtm6vMqtRNqmsVHJKJN2Jslr-mj4poUPQHg8UABAfUj-d2doX2dSgvs0lTPC1G6gXqxCK9Vi6gaDGk4QE',
      5: 'https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8',
      10: 'https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE',
      20: 'https://lh3.googleusercontent.com/aida-public/AB6AXuAgWa32e2tC7Oqj6xaGtLFsrHpCnGZoSIsZETl3koFGkh3Yfv1SePboDpMUSULj1vKGVTG6JMF3Gd2AU9n-_CiSbLUGvehd0ddTn0LBwHi8S308I5Lr6ln1iLbXVoLuz5GmpG9L0SPJx59H5LukjIwYxZJMeJ9LBth6JbeOytozhasJF-BhOqeMsP0x8wYKbVvp07CvjkFslQIvbwblvc3yMcF1VtJit-T9xEj0Tu1XCJ9XnlxHbEhfuk9icdcrtMKtxDHwYLCrJXA'
    };
    
    // Find the appropriate icon based on level
    let selectedIcon = iconUrls[1]; // Default
    if (gameState.playerLevel >= 20) selectedIcon = iconUrls[20];
    else if (gameState.playerLevel >= 10) selectedIcon = iconUrls[10];
    else if (gameState.playerLevel >= 5) selectedIcon = iconUrls[5];
    
    playerIconEl.style.backgroundImage = `url("${selectedIcon}")`;
  }
}

function checkLevelUnlocks() {
  // All towers now require shop purchase - no automatic unlocks
  // Players must buy towers from the shop using shop gold
  // Level requirements are checked in the buyTower function
  console.log('Level unlocks checked - all towers require shop purchase');
}

function updateLevelSelectionUI() {
  const levelSelectionGoldEl = document.getElementById('levelSelectionGoldDisplay');
  if (levelSelectionGoldEl) levelSelectionGoldEl.textContent = gameState.testMode ? 'âˆž' : gameState.gold;
  
  const levelSelectionGemsEl = document.getElementById('levelSelectionGemsDisplay');
  if (levelSelectionGemsEl) levelSelectionGemsEl.textContent = gameState.gems || 0;
  
  // Reset play button text if no level is selected
  const playButton = document.getElementById('playButton');
  if (playButton && !gameState.currentLevel) {
    playButton.textContent = 'Choose a level to start';
  }
  
  // Update frozen map visibility
  const frozenMapCard = document.querySelector('[onclick*="frozen"]');
  if (frozenMapCard) {
    if (gameState.frozenMapUnlocked) {
      // Show as unlocked
      frozenMapCard.style.borderColor = '#10b981'; // Green border
      frozenMapCard.style.cursor = 'pointer';
      frozenMapCard.style.opacity = '1';
      
      // Update lock icon to checkmark
      const lockIcon = frozenMapCard.querySelector('.material-symbols-outlined');
      if (lockIcon) {
        lockIcon.textContent = 'check_circle';
        lockIcon.style.color = '#10b981';
      }
      
      // Update unlock text
      const unlockText = frozenMapCard.querySelector('.text-gray-400.text-xs');
      if (unlockText) {
        unlockText.textContent = 'Unlocked!';
        unlockText.style.color = '#10b981';
      }
    } else {
      // Show as locked
      frozenMapCard.style.borderColor = 'rgba(255, 255, 255, 0.2)';
      frozenMapCard.style.cursor = 'not-allowed';
      frozenMapCard.style.opacity = '0.7';
      
      // Update lock icon
      const lockIcon = frozenMapCard.querySelector('.material-symbols-outlined');
      if (lockIcon) {
        lockIcon.textContent = 'lock';
        lockIcon.style.color = 'rgba(255, 255, 255, 0.5)';
      }
      
      // Update unlock text
      const unlockText = frozenMapCard.querySelector('.text-gray-400.text-xs');
      if (unlockText) {
        unlockText.textContent = 'Complete Wave 20 to unlock';
        unlockText.style.color = 'rgba(156, 163, 175, 1)';
      }
    }
  }
  
  // Update desert map visibility
  const desertMapCard = document.querySelector('[onclick*="desert"]');
  if (desertMapCard) {
    if (gameState.desertMapUnlocked) {
      // Show as unlocked
      desertMapCard.style.borderColor = '#10b981'; // Green border
      desertMapCard.style.cursor = 'pointer';
      desertMapCard.style.opacity = '1';
      
      // Update lock icon to checkmark
      const lockIcon = desertMapCard.querySelector('.material-symbols-outlined');
      if (lockIcon) {
        lockIcon.textContent = 'check_circle';
        lockIcon.style.color = '#10b981';
      }
      
      // Update unlock text
      const unlockText = desertMapCard.querySelector('.text-gray-400.text-xs');
      if (unlockText) {
        unlockText.textContent = 'Unlocked!';
        unlockText.style.color = '#10b981';
      }
    } else {
      // Show as locked
      desertMapCard.style.borderColor = 'rgba(255, 255, 255, 0.2)';
      desertMapCard.style.cursor = 'not-allowed';
      desertMapCard.style.opacity = '0.7';
      
      // Update lock icon
      const lockIcon = desertMapCard.querySelector('.material-symbols-outlined');
      if (lockIcon) {
        lockIcon.textContent = 'lock';
        lockIcon.style.color = 'rgba(255, 255, 255, 0.5)';
      }
      
      // Update unlock text
      const unlockText = desertMapCard.querySelector('.text-gray-400.text-xs');
      if (unlockText) {
        unlockText.textContent = 'Complete Frozen Pass to unlock';
        unlockText.style.color = 'rgba(156, 163, 175, 1)';
      }
    }
  }
}

function claimReward() {
  if (gameState.shopGold > 0) {
    const goldToClaim = gameState.shopGold;
    gameState.gold += gameState.shopGold;
    gameState.shopGold = 0;
    updateMainMenuUI();
    updateLevelSelectionUI();
    updateShopUI();
    updateRewardsUI();
    autoSave(); // Auto-save after claiming rewards
    alert(`Claimed ${goldToClaim} gold! Your total gold is now ${gameState.gold}.`);
  } else {
    alert('No gold to claim! Complete waves to earn gold.');
  }
}

function updateRewardsUI() {
  const claimableGoldEl = document.getElementById('claimableGold');
  const claimButtonEl = document.getElementById('claimRewardButton');
  
  if (claimableGoldEl) {
    claimableGoldEl.textContent = `${gameState.shopGold} Gold Available`;
  }
  
  if (claimButtonEl) {
    if (gameState.shopGold > 0) {
      claimButtonEl.textContent = `Claim ${gameState.shopGold} Gold`;
      claimButtonEl.disabled = false;
      claimButtonEl.style.opacity = '1';
    } else {
      claimButtonEl.textContent = 'No Gold to Claim';
      claimButtonEl.disabled = true;
      claimButtonEl.style.opacity = '0.5';
    }
  }
}

function updateInventoryScreenUI() {
  const inventoryGoldEl = document.getElementById('inventoryGoldDisplay');
  if (inventoryGoldEl) inventoryGoldEl.textContent = gameState.testMode ? 'âˆž' : gameState.gold;
  
  // Update loadout count
  const loadoutCountEl = document.getElementById('loadoutCount');
  if (loadoutCountEl) loadoutCountEl.textContent = gameState.equippedTowers.length;
  
  // Update loadout display
  const loadoutDisplayEl = document.getElementById('loadoutDisplay');
  if (loadoutDisplayEl) {
    if (gameState.equippedTowers.length === 0) {
      loadoutDisplayEl.innerHTML = '<p class="text-gray-400 text-sm">No towers equipped. Equip up to 5 towers from below.</p>';
    } else {
      const towerNames = {
        archer: 'Archer',
        cannon: 'Cannon',
        mage: 'Mage',
        ice: 'Ice',
        poison: 'Poison',
        lightning: 'Lightning',
        shield: 'Support',
        fire: 'Fire'
      };
      loadoutDisplayEl.innerHTML = gameState.equippedTowers.map(towerType => 
        `<div class="flex flex-col items-center gap-1 p-2 bg-primary/20 rounded-lg border border-primary/50">
          <p class="text-white text-xs font-bold">${towerNames[towerType]}</p>
        </div>`
      ).join('');
    }
  }
  
  // Update tower unlock status and equip buttons
  const towers = ['archer', 'cannon', 'mage', 'ice', 'poison', 'lightning', 'shield', 'fire'];
  towers.forEach(towerType => {
    const isUnlocked = gameState.unlockedTowers[towerType];
    const isEquipped = gameState.equippedTowers.includes(towerType);
    const statusEl = document.getElementById(`inventory${towerType.charAt(0).toUpperCase() + towerType.slice(1)}Status`);
    const equipBtn = document.getElementById(`inventory${towerType.charAt(0).toUpperCase() + towerType.slice(1)}EquipBtn`);
    const unequipBtn = document.getElementById(`inventory${towerType.charAt(0).toUpperCase() + towerType.slice(1)}UnequipBtn`);
    
    if (statusEl) {
      statusEl.textContent = isUnlocked ? 'Unlocked' : 'Locked';
    }
    
    if (equipBtn && unequipBtn) {
      if (isUnlocked) {
        if (isEquipped) {
          equipBtn.classList.add('hidden');
          unequipBtn.classList.remove('hidden');
        } else {
          equipBtn.classList.remove('hidden');
          unequipBtn.classList.add('hidden');
        }
      } else {
        equipBtn.classList.add('hidden');
        unequipBtn.classList.add('hidden');
      }
    }
  });
}

function getTowerAbility(towerType) {
  // Define abilities for each tower type
  const abilities = {
    archer: 'Piercing Shot - Arrows pierce through 2 enemies',
    cannon: 'Splash Damage - Explosions damage nearby enemies',
    mage: 'Magic Overload - Double damage to armored enemies',
    ice: 'Frost Nova - Slows all enemies in range',
    poison: 'Poison Cloud - Creates lingering poison area',
    lightning: 'Chain Lightning - Jumps to 3 additional enemies',
    shield: 'Enhanced Support - Creates larger, longer-lasting barriers',
    fire: 'Inferno - Burns all enemies on map for 70 damage + 15/s burn'
  };
  return abilities[towerType] || 'No ability';
}

function openUpgradePanel(tower, towerIndex) {
  gameState.selectedTowerForUpgrade = { tower, index: towerIndex };
  
  const panel = document.getElementById('upgradePanel');
  const nameEl = document.getElementById('upgradeTowerName');
  const levelEl = document.getElementById('upgradeLevel');
  const damageEl = document.getElementById('upgradeDamage');
  const rangeEl = document.getElementById('upgradeRange');
  const costEl = document.getElementById('upgradeCost');
  const upgradeBtn = document.getElementById('upgradeButton');
  const abilityContainer = document.getElementById('upgradeAbilityContainer');
  const abilityEl = document.getElementById('upgradeAbility');
  
  if (!panel) return;
  
  // Get tower level (default to 1 if not set)
  const towerLevel = tower.level || 1;
  const upgradeCost = 50 * towerLevel; // Cost increases with level
  
  // Capitalize tower type name
  const towerName = tower.type.charAt(0).toUpperCase() + tower.type.slice(1) + ' Tower';
  
  if (nameEl) nameEl.textContent = towerName;
  if (levelEl) levelEl.textContent = towerLevel;
  if (damageEl) damageEl.textContent = Math.floor(tower.damage);
  if (rangeEl) rangeEl.textContent = Math.floor(tower.range);
  if (costEl) costEl.textContent = upgradeCost;
  
  // Show ability if tower is level 3 or higher, or show preview if upgrading to level 3
  if (towerLevel >= 3) {
    if (abilityContainer) abilityContainer.style.display = 'block';
    if (abilityEl) {
      abilityEl.textContent = getTowerAbility(tower.type);
      abilityEl.className = 'text-yellow-300 text-xs';
    }
  } else if (towerLevel === 2 && (gameState.testMode || gameState.gold >= upgradeCost)) {
    // Show preview of ability that will unlock at level 3
    if (abilityContainer) abilityContainer.style.display = 'block';
    if (abilityEl) {
      abilityEl.textContent = `Unlocks at Lv.3: ${getTowerAbility(tower.type)}`;
      abilityEl.className = 'text-gray-400 text-xs italic';
    }
  } else {
    if (abilityContainer) abilityContainer.style.display = 'none';
    if (abilityEl) abilityEl.textContent = '';
  }
  
  // Enable/disable upgrade button based on gold (or test mode)
  if (upgradeBtn) {
    const hasEnoughGold = gameState.testMode || gameState.gold >= upgradeCost;
    if (hasEnoughGold && towerLevel < 5) {
      upgradeBtn.disabled = false;
      upgradeBtn.style.opacity = '1';
      upgradeBtn.style.cursor = 'pointer';
      const costText = gameState.testMode ? '(Free)' : `${upgradeCost} gold`;
      // Update button text while preserving onclick
      const costSpan = document.getElementById('upgradeCost');
      if (costSpan) {
        costSpan.textContent = costText;
      } else {
        upgradeBtn.innerHTML = `Upgrade (<span id="upgradeCost" class="text-red-500">${costText}</span>)`;
      }
    } else {
      upgradeBtn.disabled = true;
      upgradeBtn.style.opacity = '0.5';
      upgradeBtn.style.cursor = 'not-allowed';
      if (towerLevel >= 5) {
        upgradeBtn.innerHTML = 'Max Level Reached';
      } else {
        upgradeBtn.innerHTML = `Upgrade (<span id="upgradeCost" class="text-red-500">${upgradeCost}</span> gold) - Insufficient Funds`;
      }
    }
  }
  
  panel.style.display = 'block';
}

function closeUpgradePanel() {
  const panel = document.getElementById('upgradePanel');
  if (panel) panel.style.display = 'none';
  gameState.selectedTowerForUpgrade = null;
  // Clear any tower placement selection when closing upgrade panel
  gameState.selectedTower = null;
}

function activateTowerAbility(towerType) {
  // Check if there are any towers of this type on the map
  const towersOfType = gameState.towers.filter(t => t.type === towerType);
  
  if (towersOfType.length === 0) {
    alert(`No ${towerType} towers placed on the map!`);
    return;
  }
  
  // Activate ability for all towers of this type
  if (towerType === 'archer') {
    // Check if ability is on cooldown
    if (gameState.archerAbilityCooldownUntil && Date.now() < gameState.archerAbilityCooldownUntil) {
      const timeLeft = Math.ceil((gameState.archerAbilityCooldownUntil - Date.now()) / 1000);
      alert(`Ability is on cooldown! ${timeLeft} seconds remaining.`);
      return;
    }
    
    // Check if there are any level 3+ archer towers
    const eligibleTowers = towersOfType.filter(t => (t.level || 1) >= 3);
    
    if (eligibleTowers.length === 0) {
      alert(`No level 3+ Archer towers found! Upgrade your Archer towers to level 3 to use this ability.`);
      return;
    }
    
    const btn = document.getElementById('archerAbilityBtn');
    if (btn && btn.disabled) {
      // Already on cooldown
      return;
    }
    
    const duration = 10000; // 10 seconds ability duration
    const cooldown = 30000; // 30 seconds cooldown after ability ends
    
    // Only activate ability for level 3+ towers
    eligibleTowers.forEach(tower => {
      tower.abilityActiveUntil = Date.now() + duration;
    });
    
    // Set global cooldown (starts after ability duration ends)
    gameState.archerAbilityCooldownUntil = Date.now() + duration + cooldown;
    
    // Update button to show cooldown
    if (btn) {
      btn.disabled = true;
      // Clear any existing countdown
      if (btn._countdownInterval) {
        clearInterval(btn._countdownInterval);
      }
      const originalHTML = btn.innerHTML;
      
      // Show ability active duration first, then cooldown
      let abilityTimeLeft = 10;
      const abilityInterval = setInterval(() => {
        abilityTimeLeft--;
        if (abilityTimeLeft > 0) {
          btn.innerHTML = `<span class="material-symbols-outlined text-2xl">bolt</span><span class="text-xs font-bold mt-1">${abilityTimeLeft}s</span>`;
        } else {
          clearInterval(abilityInterval);
          // Then show cooldown (30 seconds remaining)
          let cooldownLeft = 30;
          btn._countdownInterval = setInterval(() => {
            cooldownLeft--;
            if (cooldownLeft > 0) {
              btn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">bolt</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
            } else {
              btn.disabled = false;
              btn.innerHTML = originalHTML;
              clearInterval(btn._countdownInterval);
              btn._countdownInterval = null;
              gameState.archerAbilityCooldownUntil = null;
            }
          }, 1000);
        }
      }, 1000);
    }
    
    alert(`Rapid Fire activated! ${eligibleTowers.length} level 3+ Archer tower(s) now have 2x attack speed for 10 seconds.`);
  } else if (towerType === 'cannon') {
    // Check if ability is on cooldown
    if (gameState.cannonAbilityCooldownUntil && Date.now() < gameState.cannonAbilityCooldownUntil) {
      const timeLeft = Math.ceil((gameState.cannonAbilityCooldownUntil - Date.now()) / 1000);
      alert(`Ability is on cooldown! ${timeLeft} seconds remaining.`);
      return;
    }
    
    // Check if there are any level 3+ cannon towers
    const eligibleTowers = towersOfType.filter(t => (t.level || 1) >= 3);
    
    if (eligibleTowers.length === 0) {
      alert(`No level 3+ Cannon towers found! Upgrade your Cannon towers to level 3 to use this ability.`);
      return;
    }
    
    const btn = document.getElementById('cannonAbilityBtn');
    if (btn && btn.disabled) {
      // Already on cooldown
      return;
    }
    
    const duration = 10000; // 10 seconds ability duration
    const cooldown = 30000; // 30 seconds cooldown after ability ends
    
    // Only activate ability for level 3+ towers
    eligibleTowers.forEach(tower => {
      tower.abilityActiveUntil = Date.now() + duration;
    });
    
    // Set global cooldown (starts after ability duration ends)
    gameState.cannonAbilityCooldownUntil = Date.now() + duration + cooldown;
    
    // Update button to show cooldown
    if (btn) {
      btn.disabled = true;
      // Clear any existing countdown
      if (btn._countdownInterval) {
        clearInterval(btn._countdownInterval);
      }
      const originalHTML = btn.innerHTML;
      
      // Show ability active duration first, then cooldown
      let abilityTimeLeft = 10;
      const abilityInterval = setInterval(() => {
        abilityTimeLeft--;
        if (abilityTimeLeft > 0) {
          btn.innerHTML = `<span class="material-symbols-outlined text-2xl">my_location</span><span class="text-xs font-bold mt-1">${abilityTimeLeft}s</span>`;
        } else {
          clearInterval(abilityInterval);
          // Then show cooldown (30 seconds remaining)
          let cooldownLeft = 30;
          btn._countdownInterval = setInterval(() => {
            cooldownLeft--;
            if (cooldownLeft > 0) {
              btn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">my_location</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
            } else {
              btn.disabled = false;
              btn.innerHTML = originalHTML;
              clearInterval(btn._countdownInterval);
              btn._countdownInterval = null;
              gameState.cannonAbilityCooldownUntil = null;
            }
          }, 1000);
        }
      }, 1000);
    }
    
    alert(`Extended Range activated! ${eligibleTowers.length} level 3+ Cannon tower(s) now have 2x range for 10 seconds.`);
  } else if (towerType === 'fire') {
    // Check if ability is on cooldown
    if (gameState.fireAbilityCooldownUntil && Date.now() < gameState.fireAbilityCooldownUntil) {
      const timeLeft = Math.ceil((gameState.fireAbilityCooldownUntil - Date.now()) / 1000);
      alert(`Ability is on cooldown! ${timeLeft} seconds remaining.`);
      return;
    }
    
    // Check if there are any level 3+ fire towers
    const eligibleTowers = towersOfType.filter(t => (t.level || 1) >= 3);
    
    if (eligibleTowers.length === 0) {
      alert(`No level 3+ Fire towers found! Upgrade your Fire towers to level 3 to use this ability.`);
      return;
    }
    
    const btn = document.getElementById('fireAbilityBtn');
    if (btn && btn.disabled) {
      // Already on cooldown
      return;
    }
    
    // Inferno ability: Damage all enemies on the map for 70 damage and apply burn
    const initialDamage = 70;
    const burnDamagePerSecond = 15;
    const burnDuration = 5000; // 5 seconds of burn
    
    // Damage all enemies on the map
    gameState.zombies.forEach(zombie => {
      if (zombie.health > 0) {
        zombie.health -= initialDamage;
        
        // Apply burn effect (15 damage per second)
        zombie.onFire = Date.now() + burnDuration;
        zombie.burnDamage = burnDamagePerSecond;
      }
    });
    
    const cooldown = 60000; // 60 seconds cooldown
    gameState.fireAbilityCooldownUntil = Date.now() + cooldown;
    
    // Update button to show cooldown
    if (btn) {
      btn.disabled = true;
      // Clear any existing countdown
      if (btn._countdownInterval) {
        clearInterval(btn._countdownInterval);
      }
      const originalHTML = btn.innerHTML;
      
      // Show cooldown (60 seconds)
      let cooldownLeft = 60;
      btn._countdownInterval = setInterval(() => {
        cooldownLeft--;
        if (cooldownLeft > 0) {
          btn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">local_fire_department</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
        } else {
          btn.disabled = false;
          btn.innerHTML = originalHTML;
          clearInterval(btn._countdownInterval);
          btn._countdownInterval = null;
          gameState.fireAbilityCooldownUntil = null;
        }
      }, 1000);
    }
    
    alert(`Inferno activated! All enemies on the map took 70 damage and are burning for 15 damage per second!`);
  }
}

function activateSupportAbility(abilityType) {
  // Check if there are any support towers on the map
  const supportTowers = gameState.towers.filter(t => t.type === 'shield');
  
  if (supportTowers.length === 0) {
    alert(`No Support towers placed on the map!`);
    return;
  }
  
  if (abilityType === 'wall') {
    // Check if wall ability is on cooldown
    if (gameState.supportWallCooldownUntil && Date.now() < gameState.supportWallCooldownUntil) {
      const timeLeft = Math.ceil((gameState.supportWallCooldownUntil - Date.now()) / 1000);
      alert(`Wall ability is on cooldown! ${timeLeft} seconds remaining.`);
      return;
    }
    
    const btn = document.getElementById('shieldWallAbilityBtn');
    if (btn && btn.disabled) {
      return;
    }
    
    // Create barrier in middle of path
    const middleProgress = (path.length - 1) / 2;
    const barrierSize = 25;
    const barrierId = `barrier_${Date.now()}`;
    gameState.barriers = gameState.barriers || [];
    gameState.barriers.push({
      id: barrierId,
      progress: middleProgress,
      duration: 150, // 5 seconds at 30 FPS (150 frames)
      radius: barrierSize,
      x: 0,
      y: 0
    });
    
    const cooldown = 10000; // 10 seconds cooldown
    gameState.supportWallCooldownUntil = Date.now() + cooldown;
    
    // Update button to show cooldown
    if (btn) {
      btn.disabled = true;
      if (btn._countdownInterval) {
        clearInterval(btn._countdownInterval);
      }
      const originalHTML = btn.innerHTML;
      
      let cooldownLeft = 10;
      btn._countdownInterval = setInterval(() => {
        cooldownLeft--;
        if (cooldownLeft > 0) {
          btn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">wallpaper</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
        } else {
          btn.disabled = false;
          btn.innerHTML = originalHTML;
          clearInterval(btn._countdownInterval);
          btn._countdownInterval = null;
          gameState.supportWallCooldownUntil = null;
        }
      }, 1000);
    }
    
    alert(`Wall created! A barrier has been placed in the middle of the path for 5 seconds.`);
  } else if (abilityType === 'heal') {
    // Check if heal ability is on cooldown
    if (gameState.supportHealCooldownUntil && Date.now() < gameState.supportHealCooldownUntil) {
      const timeLeft = Math.ceil((gameState.supportHealCooldownUntil - Date.now()) / 1000);
      alert(`Heal ability is on cooldown! ${timeLeft} seconds remaining.`);
      return;
    }
    
    const btn = document.getElementById('shieldHealAbilityBtn');
    if (btn && btn.disabled) {
      return;
    }
    
    // Heal base for 1 life (max 10 lives)
    if (gameState.lives < 10) {
      gameState.lives = Math.min(gameState.lives + 1, 10); // Cap at 10 lives
      updateUI(); // Update lives display
    } else {
      alert(`Base is already at maximum health (10 lives)!`);
      return;
    }
    
    const cooldown = 10000; // 10 seconds cooldown
    gameState.supportHealCooldownUntil = Date.now() + cooldown;
    
    // Update button to show cooldown
    if (btn) {
      btn.disabled = true;
      if (btn._countdownInterval) {
        clearInterval(btn._countdownInterval);
      }
      const originalHTML = btn.innerHTML;
      
      let cooldownLeft = 10;
      btn._countdownInterval = setInterval(() => {
        cooldownLeft--;
        if (cooldownLeft > 0) {
          btn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">healing</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
        } else {
          btn.disabled = false;
          btn.innerHTML = originalHTML;
          clearInterval(btn._countdownInterval);
          btn._countdownInterval = null;
          gameState.supportHealCooldownUntil = null;
        }
      }, 1000);
    }
    
    alert(`Base healed! +1 life restored.`);
  } else if (abilityType === 'boost') {
    // Check if boost ability is on cooldown
    if (gameState.supportBoostCooldownUntil && Date.now() < gameState.supportBoostCooldownUntil) {
      const timeLeft = Math.ceil((gameState.supportBoostCooldownUntil - Date.now()) / 1000);
      alert(`Boost ability is on cooldown! ${timeLeft} seconds remaining.`);
      return;
    }
    
    const btn = document.getElementById('shieldBoostAbilityBtn');
    if (btn && btn.disabled) {
      return;
    }
    
    // Activate 2x attack speed for all towers for 10 seconds
    const duration = 10000; // 10 seconds
    gameState.allTowersBoostUntil = Date.now() + duration;
    
    const cooldown = 30000; // 30 seconds cooldown
    gameState.supportBoostCooldownUntil = Date.now() + duration + cooldown;
    
    // Update button to show cooldown
    if (btn) {
      btn.disabled = true;
      if (btn._countdownInterval) {
        clearInterval(btn._countdownInterval);
      }
      const originalHTML = btn.innerHTML;
      
      // Show ability active duration first, then cooldown
      let abilityTimeLeft = 10;
      const abilityInterval = setInterval(() => {
        abilityTimeLeft--;
        if (abilityTimeLeft > 0) {
          btn.innerHTML = `<span class="material-symbols-outlined text-2xl">speed</span><span class="text-xs font-bold mt-1">${abilityTimeLeft}s</span>`;
        } else {
          clearInterval(abilityInterval);
          // Then show cooldown (30 seconds remaining)
          let cooldownLeft = 30;
          btn._countdownInterval = setInterval(() => {
            cooldownLeft--;
            if (cooldownLeft > 0) {
              btn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">speed</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
            } else {
              btn.disabled = false;
              btn.innerHTML = originalHTML;
              clearInterval(btn._countdownInterval);
              btn._countdownInterval = null;
              gameState.supportBoostCooldownUntil = null;
            }
          }, 1000);
        }
      }, 1000);
    }
    
    alert(`Combat Boost activated! All towers now have 2x attack speed for 10 seconds.`);
  }
}

function updateTowerAbilityButtons() {
  // Show ability buttons only if there are towers of that type placed AND level 3+
  const archerBtn = document.getElementById('archerAbilityBtn');
  const cannonBtn = document.getElementById('cannonAbilityBtn');
  const fireBtn = document.getElementById('fireAbilityBtn');
  const shieldWallBtn = document.getElementById('shieldWallAbilityBtn');
  const shieldHealBtn = document.getElementById('shieldHealAbilityBtn');
  const shieldBoostBtn = document.getElementById('shieldBoostAbilityBtn');
  
  if (archerBtn) {
    const hasEligibleArcherTowers = gameState.towers && gameState.towers.some(t => t.type === 'archer' && (t.level || 1) >= 3);
    
    if (hasEligibleArcherTowers) {
      archerBtn.style.display = 'flex';
      
      // Check if on cooldown
      if (gameState.archerAbilityCooldownUntil && Date.now() < gameState.archerAbilityCooldownUntil) {
        archerBtn.disabled = true;
        const timeLeft = Math.ceil((gameState.archerAbilityCooldownUntil - Date.now()) / 1000);
        // Update countdown if not already running
        if (!archerBtn._countdownInterval) {
          const originalHTML = archerBtn.innerHTML;
          let remaining = timeLeft;
          
          // Check if any towers still have active ability
          const hasActiveAbility = gameState.towers.some(t => t.type === 'archer' && t.abilityActiveUntil && Date.now() < t.abilityActiveUntil);
          
          if (hasActiveAbility && remaining > 30) {
            // Ability is still active, show ability duration first
            let abilityTimeLeft = remaining - 30;
            const abilityInterval = setInterval(() => {
              abilityTimeLeft--;
              if (abilityTimeLeft > 0) {
                archerBtn.innerHTML = `<span class="material-symbols-outlined text-2xl">bolt</span><span class="text-xs font-bold mt-1">${abilityTimeLeft}s</span>`;
              } else {
                clearInterval(abilityInterval);
                // Then show cooldown
                let cooldownLeft = 30;
                archerBtn._countdownInterval = setInterval(() => {
                  cooldownLeft--;
                  if (cooldownLeft > 0) {
                    archerBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">bolt</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
                  } else {
                    archerBtn.disabled = false;
                    archerBtn.innerHTML = originalHTML;
                    clearInterval(archerBtn._countdownInterval);
                    archerBtn._countdownInterval = null;
                    gameState.archerAbilityCooldownUntil = null;
                  }
                }, 1000);
              }
            }, 1000);
          } else {
            // Just show cooldown
            archerBtn._countdownInterval = setInterval(() => {
              remaining--;
              if (remaining > 0) {
                archerBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">bolt</span><span class="text-xs font-bold mt-1 text-gray-400">${remaining}s</span>`;
              } else {
                archerBtn.disabled = false;
                archerBtn.innerHTML = originalHTML;
                clearInterval(archerBtn._countdownInterval);
                archerBtn._countdownInterval = null;
                gameState.archerAbilityCooldownUntil = null;
              }
            }, 1000);
          }
        }
      } else if (!archerBtn._countdownInterval) {
        // Not on cooldown, make sure button is enabled
        archerBtn.disabled = false;
      }
    } else {
      archerBtn.style.display = 'none';
    }
  }
  
  if (cannonBtn) {
    const hasEligibleCannonTowers = gameState.towers && gameState.towers.some(t => t.type === 'cannon' && (t.level || 1) >= 3);
    
    if (hasEligibleCannonTowers) {
      cannonBtn.style.display = 'flex';
      
      // Check if on cooldown
      if (gameState.cannonAbilityCooldownUntil && Date.now() < gameState.cannonAbilityCooldownUntil) {
        cannonBtn.disabled = true;
        const timeLeft = Math.ceil((gameState.cannonAbilityCooldownUntil - Date.now()) / 1000);
        // Update countdown if not already running
        if (!cannonBtn._countdownInterval) {
          const originalHTML = cannonBtn.innerHTML;
          let remaining = timeLeft;
          
          // Check if any towers still have active ability
          const hasActiveAbility = gameState.towers.some(t => t.type === 'cannon' && t.abilityActiveUntil && Date.now() < t.abilityActiveUntil);
          
          if (hasActiveAbility && remaining > 30) {
            // Ability is still active, show ability duration first
            let abilityTimeLeft = remaining - 30;
            const abilityInterval = setInterval(() => {
              abilityTimeLeft--;
              if (abilityTimeLeft > 0) {
                cannonBtn.innerHTML = `<span class="material-symbols-outlined text-2xl">my_location</span><span class="text-xs font-bold mt-1">${abilityTimeLeft}s</span>`;
              } else {
                clearInterval(abilityInterval);
                // Then show cooldown
                let cooldownLeft = 30;
                cannonBtn._countdownInterval = setInterval(() => {
                  cooldownLeft--;
                  if (cooldownLeft > 0) {
                    cannonBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">my_location</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownLeft}s</span>`;
                  } else {
                    cannonBtn.disabled = false;
                    cannonBtn.innerHTML = originalHTML;
                    clearInterval(cannonBtn._countdownInterval);
                    cannonBtn._countdownInterval = null;
                    gameState.cannonAbilityCooldownUntil = null;
                  }
                }, 1000);
              }
            }, 1000);
          } else {
            // Just show cooldown
            cannonBtn._countdownInterval = setInterval(() => {
              remaining--;
              if (remaining > 0) {
                cannonBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">my_location</span><span class="text-xs font-bold mt-1 text-gray-400">${remaining}s</span>`;
              } else {
                cannonBtn.disabled = false;
                cannonBtn.innerHTML = originalHTML;
                clearInterval(cannonBtn._countdownInterval);
                cannonBtn._countdownInterval = null;
                gameState.cannonAbilityCooldownUntil = null;
              }
            }, 1000);
          }
        }
      } else if (!cannonBtn._countdownInterval) {
        // Not on cooldown, make sure button is enabled
        cannonBtn.disabled = false;
      }
    } else {
      cannonBtn.style.display = 'none';
    }
  }
  
  if (fireBtn) {
    const hasEligibleFireTowers = gameState.towers && gameState.towers.some(t => t.type === 'fire' && (t.level || 1) >= 3);
    
    if (hasEligibleFireTowers) {
      fireBtn.style.display = 'flex';
      
      // Check if on cooldown
      if (gameState.fireAbilityCooldownUntil && Date.now() < gameState.fireAbilityCooldownUntil) {
        fireBtn.disabled = true;
        const timeLeft = Math.ceil((gameState.fireAbilityCooldownUntil - Date.now()) / 1000);
        // Update countdown if not already running
        if (!fireBtn._countdownInterval) {
          const originalHTML = fireBtn.innerHTML;
          let remaining = timeLeft;
          
          // Just show cooldown (fire ability is instant, no duration)
          fireBtn._countdownInterval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
              fireBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">local_fire_department</span><span class="text-xs font-bold mt-1 text-gray-400">${remaining}s</span>`;
            } else {
              fireBtn.disabled = false;
              fireBtn.innerHTML = originalHTML;
              clearInterval(fireBtn._countdownInterval);
              fireBtn._countdownInterval = null;
              gameState.fireAbilityCooldownUntil = null;
            }
          }, 1000);
        }
      } else if (!fireBtn._countdownInterval) {
        // Not on cooldown, make sure button is enabled
        fireBtn.disabled = false;
      }
    } else {
      fireBtn.style.display = 'none';
    }
  }
  
  // Support tower buttons - show if any support towers are placed (no level requirement)
  if (shieldWallBtn) {
    const hasSupportTowers = gameState.towers && gameState.towers.some(t => t.type === 'shield');
    
    if (hasSupportTowers) {
      shieldWallBtn.style.display = 'flex';
      
      // Check if on cooldown
      if (gameState.supportWallCooldownUntil && Date.now() < gameState.supportWallCooldownUntil) {
        shieldWallBtn.disabled = true;
        const timeLeft = Math.ceil((gameState.supportWallCooldownUntil - Date.now()) / 1000);
        if (!shieldWallBtn._countdownInterval) {
          const originalHTML = shieldWallBtn.innerHTML;
          let remaining = timeLeft;
          
          shieldWallBtn._countdownInterval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
              shieldWallBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">wallpaper</span><span class="text-xs font-bold mt-1 text-gray-400">${remaining}s</span>`;
            } else {
              shieldWallBtn.disabled = false;
              shieldWallBtn.innerHTML = originalHTML;
              clearInterval(shieldWallBtn._countdownInterval);
              shieldWallBtn._countdownInterval = null;
              gameState.supportWallCooldownUntil = null;
            }
          }, 1000);
        }
      } else if (!shieldWallBtn._countdownInterval) {
        shieldWallBtn.disabled = false;
      }
    } else {
      shieldWallBtn.style.display = 'none';
    }
  }
  
  if (shieldHealBtn) {
    const hasSupportTowers = gameState.towers && gameState.towers.some(t => t.type === 'shield');
    
    if (hasSupportTowers) {
      shieldHealBtn.style.display = 'flex';
      
      // Check if on cooldown
      if (gameState.supportHealCooldownUntil && Date.now() < gameState.supportHealCooldownUntil) {
        shieldHealBtn.disabled = true;
        const timeLeft = Math.ceil((gameState.supportHealCooldownUntil - Date.now()) / 1000);
        if (!shieldHealBtn._countdownInterval) {
          const originalHTML = shieldHealBtn.innerHTML;
          let remaining = timeLeft;
          
          shieldHealBtn._countdownInterval = setInterval(() => {
            remaining--;
            if (remaining > 0) {
              shieldHealBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">healing</span><span class="text-xs font-bold mt-1 text-gray-400">${remaining}s</span>`;
            } else {
              shieldHealBtn.disabled = false;
              shieldHealBtn.innerHTML = originalHTML;
              clearInterval(shieldHealBtn._countdownInterval);
              shieldHealBtn._countdownInterval = null;
              gameState.supportHealCooldownUntil = null;
            }
          }, 1000);
        }
      } else if (!shieldHealBtn._countdownInterval) {
        shieldHealBtn.disabled = false;
      }
    } else {
      shieldHealBtn.style.display = 'none';
    }
  }
  
  if (shieldBoostBtn) {
    const hasSupportTowers = gameState.towers && gameState.towers.some(t => t.type === 'shield');
    
    if (hasSupportTowers) {
      shieldBoostBtn.style.display = 'flex';
      
      // Check if on cooldown or if boost is active
      const isBoostActive = gameState.allTowersBoostUntil && Date.now() < gameState.allTowersBoostUntil;
      const isOnCooldown = gameState.supportBoostCooldownUntil && Date.now() < gameState.supportBoostCooldownUntil;
      
      if (isBoostActive || isOnCooldown) {
        shieldBoostBtn.disabled = true;
        const timeLeft = isBoostActive 
          ? Math.ceil((gameState.allTowersBoostUntil - Date.now()) / 1000)
          : Math.ceil((gameState.supportBoostCooldownUntil - Date.now()) / 1000);
        
        if (!shieldBoostBtn._countdownInterval) {
          const originalHTML = shieldBoostBtn.innerHTML;
          let remaining = timeLeft;
          
          shieldBoostBtn._countdownInterval = setInterval(() => {
            remaining--;
            // Check if boost is still active or if we're in cooldown
            const stillActive = gameState.allTowersBoostUntil && Date.now() < gameState.allTowersBoostUntil;
            const stillOnCooldown = gameState.supportBoostCooldownUntil && Date.now() < gameState.supportBoostCooldownUntil;
            
            if (stillActive) {
              // Show active duration
              const activeTimeLeft = Math.ceil((gameState.allTowersBoostUntil - Date.now()) / 1000);
              if (activeTimeLeft > 0) {
                shieldBoostBtn.innerHTML = `<span class="material-symbols-outlined text-2xl">speed</span><span class="text-xs font-bold mt-1">${activeTimeLeft}s</span>`;
              } else {
                // Switch to cooldown
                const cooldownTimeLeft = Math.ceil((gameState.supportBoostCooldownUntil - Date.now()) / 1000);
                if (cooldownTimeLeft > 0) {
                  shieldBoostBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">speed</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownTimeLeft}s</span>`;
                } else {
                  shieldBoostBtn.disabled = false;
                  shieldBoostBtn.innerHTML = originalHTML;
                  clearInterval(shieldBoostBtn._countdownInterval);
                  shieldBoostBtn._countdownInterval = null;
                  gameState.supportBoostCooldownUntil = null;
                }
              }
            } else if (stillOnCooldown) {
              // Show cooldown
              const cooldownTimeLeft = Math.ceil((gameState.supportBoostCooldownUntil - Date.now()) / 1000);
              if (cooldownTimeLeft > 0) {
                shieldBoostBtn.innerHTML = `<span class="material-symbols-outlined text-2xl text-gray-400">speed</span><span class="text-xs font-bold mt-1 text-gray-400">${cooldownTimeLeft}s</span>`;
              } else {
                shieldBoostBtn.disabled = false;
                shieldBoostBtn.innerHTML = originalHTML;
                clearInterval(shieldBoostBtn._countdownInterval);
                shieldBoostBtn._countdownInterval = null;
                gameState.supportBoostCooldownUntil = null;
              }
            } else {
              shieldBoostBtn.disabled = false;
              shieldBoostBtn.innerHTML = originalHTML;
              clearInterval(shieldBoostBtn._countdownInterval);
              shieldBoostBtn._countdownInterval = null;
            }
          }, 1000);
        }
      } else if (!shieldBoostBtn._countdownInterval) {
        shieldBoostBtn.disabled = false;
      }
    } else {
      shieldBoostBtn.style.display = 'none';
    }
  }
}

function upgradeSelectedTower() {
  if (!gameState.selectedTowerForUpgrade) {
    alert('No tower selected for upgrade! Click on a tower first.');
    return;
  }
  
  const { tower, index } = gameState.selectedTowerForUpgrade;
  const towerLevel = tower.level || 1;
  
  if (towerLevel >= 5) {
    alert('Tower is already at maximum level!');
    return;
  }
  
  const upgradeCost = 50 * towerLevel;
  
  // Check if player has enough gold (or in test mode)
  const hasEnoughGold = gameState.testMode || gameState.gold >= upgradeCost;
  if (!hasEnoughGold) {
    alert(`Not enough gold! Need ${upgradeCost} gold.`);
    return;
  }
  
  // Upgrade tower
  // Only deduct gold if not in test mode
  if (!gameState.testMode) {
    gameState.gold -= upgradeCost;
  }
  const newLevel = towerLevel + 1;
  tower.level = newLevel;
  tower.damage = Math.floor(tower.damage * 1.25); // 25% damage increase
  tower.range = Math.floor(tower.range * 1.1); // 10% range increase
  
  // Unlock ability at level 3
  if (newLevel === 3 && !tower.hasAbility) {
    tower.hasAbility = true;
    alert(`âœ¨ ${tower.type.charAt(0).toUpperCase() + tower.type.slice(1)} Tower unlocked special ability: ${getTowerAbility(tower.type)}!`);
  }
  
  updateUI();
  updateTowerAbilityButtons(); // Update ability buttons after upgrade
  // Keep the panel open and refresh it with new stats
  openUpgradePanel(tower, index); // Refresh panel with new stats
  autoSave(); // Auto-save after upgrade
  
  if (gameState.soundEnabled) {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency = 600;
      oscillator.type = 'sine';
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
    } catch(e) {}
  }
}

function sellSelectedTower() {
  if (!gameState.selectedTowerForUpgrade) return;
  
  const { tower, index } = gameState.selectedTowerForUpgrade;
  const towerLevel = tower.level || 1;
  
  // Refund 50% of tower cost + upgrade costs
  const baseCost = tower.type === 'archer' ? 100 : tower.type === 'cannon' ? 150 : tower.type === 'mage' ? 200 : tower.type === 'ice' ? 200 : tower.type === 'poison' ? 150 : tower.type === 'lightning' ? 250 : tower.type === 'shield' ? 300 : tower.type === 'fire' ? 150 : 350;
  let refund = Math.floor(baseCost * 0.5);
  
  // Add refund for upgrade costs
  for (let i = 1; i < towerLevel; i++) {
    refund += Math.floor(50 * i * 0.5);
  }
  
  gameState.gold += refund;
  gameState.towers.splice(index, 1);
  closeUpgradePanel();
  updateUI();
  
  alert(`Tower sold for ${refund} gold!`);
}
</script>

<!-- Inventory Screen -->
<div id="inventory" class="screen bg-background-light dark:bg-background-dark">
  <div class="flex items-center bg-background-light dark:bg-background-dark p-4 pb-2 justify-between sticky top-0 z-10">
    <div class="text-slate-800 dark:text-white flex size-12 shrink-0 items-center justify-start cursor-pointer" onclick="goToScreen('mainMenu')">
      <span class="material-symbols-outlined text-2xl">arrow_back</span>
    </div>
    <h2 class="text-slate-900 dark:text-white text-lg font-bold leading-tight tracking-[-0.015em] flex-1 text-center">Tower Inventory</h2>
    <div class="flex w-12 items-center justify-end"></div>
  </div>
  
  <div class="flex flex-wrap gap-4 p-4">
    <div class="flex min-w-[158px] flex-1 flex-col gap-2 rounded-lg p-4 bg-slate-200/50 dark:bg-white/5">
      <p class="text-slate-700 dark:text-slate-300 text-sm font-medium leading-normal">Gold</p>
      <div class="flex items-center gap-2">
        <span class="material-symbols-outlined text-amber-400 text-2xl">monetization_on</span>
        <p id="inventoryGoldDisplay" class="text-slate-900 dark:text-white tracking-light text-2xl font-bold leading-tight">500</p>
      </div>
    </div>
  </div>
  
  <div class="p-4">
    <h3 class="text-white text-lg font-bold mb-2">Your Loadout (<span id="loadoutCount">1</span>/5)</h3>
    <div id="loadoutDisplay" class="flex gap-2 mb-6 p-3 bg-white/5 rounded-lg border border-primary/30 min-h-[80px] items-center">
      <p class="text-gray-400 text-sm">Equipped towers will appear here...</p>
    </div>
    
    <h3 class="text-white text-lg font-bold mb-4">Your Tower Collection</h3>
    <div class="grid grid-cols-2 gap-4">
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
        <p class="text-white font-bold">Archer Tower</p>
        <p class="text-gray-400 text-sm">Damage: 10 | Range: 150</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryArcherStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryArcherEquipBtn" onclick="toggleEquipTower('archer')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryArcherUnequipBtn" onclick="toggleEquipTower('archer')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
        <p class="text-white font-bold">Cannon Tower</p>
        <p class="text-gray-400 text-sm">Damage: 30 | Range: 100</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryCannonStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryCannonEquipBtn" onclick="toggleEquipTower('cannon')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryCannonUnequipBtn" onclick="toggleEquipTower('cannon')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
        <p class="text-white font-bold">Mage Tower</p>
        <p class="text-gray-400 text-sm">Damage: 40 | Range: 200</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryMageStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryMageEquipBtn" onclick="toggleEquipTower('mage')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryMageUnequipBtn" onclick="toggleEquipTower('mage')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAgWa32e2tC7Oqj6xaGtLFsrHpCnGZoSIsZETl3koFGkh3Yfv1SePboDpMUSULj1vKGVTG6JMF3Gd2AU9n-_CiSbLUGvehd0ddTn0LBwHi8S308I5Lr6ln1iLbXVoLuz5GmpG9L0SPJx59H5LukjIwYxZJMeJ9LBth6JbeOytozhasJF-BhOqeMsP0x8wYKbVvp07CvjkFslQIvbwblvc3yMcF1VtJit-T9xEj0Tu1XCJ9XnlxHbEhfuk9icdcrtMKtxDHwYLCrJXA");'></div>
        <p class="text-white font-bold">Ice Tower</p>
        <p class="text-gray-400 text-sm">Damage: 35 | Range: 120 | Slows</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryIceStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryIceEquipBtn" onclick="toggleEquipTower('ice')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryIceUnequipBtn" onclick="toggleEquipTower('ice')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
        <p class="text-white font-bold">Poison Tower</p>
        <p class="text-gray-400 text-sm">Damage: 25 | Range: 140 | DoT</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryPoisonStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryPoisonEquipBtn" onclick="toggleEquipTower('poison')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryPoisonUnequipBtn" onclick="toggleEquipTower('poison')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuAz7ZJgw2dq_VbDrv4lHlPdM7tqFwjqvCxOblUMZ19_QUh--LRF4xENaQbW69IubNAITH7FMR4K8y7--HJ2KaPxolEVF-7EtWJio586gY9wO8n6_CryRuevqec82VKfGVAYMwKk-Fis8lZ5syJqstkhvLvfmBT3syYHdoBKmNOffFNel2iktP7KnEwVbgDuYhfUVprFYvfJHK0lh7lbovRK4YmG39IzdE-JbLwV1P9SLpUN0mudGXzositsOo5FQrHO94dINa6Hvso");'></div>
        <p class="text-white font-bold">Lightning Tower</p>
        <p class="text-gray-400 text-sm">Damage: 85 | Range: 180 | Chain</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryLightningStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryLightningEquipBtn" onclick="toggleEquipTower('lightning')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryLightningUnequipBtn" onclick="toggleEquipTower('lightning')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuB-RIBEyyYY4eUnK6fFAFlk8g035yGWt17oYT5-1vXV16bbG0Pxctc-SY0lDtYaDo4SdfSkxBrjmm35N3mGTu0uUBPtr2cxpyCZBSjenPzN8B1Z9P-Lj7jebqVGGv_UggnvmJ8S2T0hkHHNPfLEru0YZDDkhp-K6ljOafbK3bgMMCHNQCbav2Wqmp1kvRSGKnL5FklzzkNzN8DV8N4ce0svjVHs8HiKac_x3cXYAW1-XWQMJfSXKvog_R48vx8huudwzcBlQb81ht8");'></div>
        <p class="text-white font-bold">Support Tower</p>
        <p class="text-gray-400 text-sm">Damage: 15 | Range: 200 | Support</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryShieldStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryShieldEquipBtn" onclick="toggleEquipTower('shield')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryShieldUnequipBtn" onclick="toggleEquipTower('shield')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
      
      <div class="flex flex-col gap-3 rounded-xl bg-white/5 border border-white/10 p-4">
        <div class="aspect-square bg-cover bg-center rounded-lg tower-icon-crop-large" style='background-image: url("https://lh3.googleusercontent.com/aida-public/AB6AXuBf1oM4d2aFDmYDrRdkIz-88tmgUyXQ8O1oFuKPdTjFJ1SPwls1Rr7BZuqlsSen_Dnfsffg_D_A4hR01zpDxGwX0PrSWtu3THN76E8dlEr2F3sTZW8RCrf1mLb72VQR21s5mj7cjxGvRHKIBKvvrAL-P6jWJ5Nd6X5Sy404WjNx7CSRMwHkgz_aoVJxy_lH3-RFjKscpuq_uFqdw95L_rnUCb4o39JdY2MlFGT80Zyet3sKeLluEo4aoUan4VOD8ink3sSpTdN2qkE");'></div>
        <p class="text-white font-bold">Fire Tower</p>
        <p class="text-gray-400 text-sm">Damage: 25 | Range: 200 | Burn</p>
        <div class="flex items-center justify-between flex-wrap gap-2">
          <span class="text-yellow-400 font-bold text-sm">Status: <span id="inventoryFireStatus">Locked</span></span>
          <div class="flex gap-2">
            <button id="inventoryFireEquipBtn" onclick="toggleEquipTower('fire')" class="bg-primary text-black px-3 py-1 rounded text-sm font-bold hidden">Equip</button>
            <button id="inventoryFireUnequipBtn" onclick="toggleEquipTower('fire')" class="bg-red-600 text-white px-3 py-1 rounded text-sm font-bold hidden">Unequip</button>
            <button onclick="goToScreen('shop')" class="bg-gray-600 text-white px-3 py-1 rounded text-sm font-bold">Unlock</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Reset Progress Button -->
    <div class="px-4 pb-4 mt-6">
      <button onclick="resetAllProgress()" class="w-full bg-red-600/80 text-white py-3 rounded-lg font-bold text-lg hover:bg-red-600 transition-colors flex items-center justify-center gap-2">
        <span class="material-symbols-outlined">refresh</span>
        Reset All Progress
      </button>
    </div>
  </div>
</div>

<!-- Settings Screen -->
<div id="settings" class="screen">
  <div class="flex items-center p-4 pb-2 justify-between">
    <div class="cursor-pointer" onclick="goToScreen('mainMenu')">
      <span class="material-symbols-outlined text-2xl">arrow_back</span>
    </div>
    <h2 class="text-white text-lg font-bold">Settings</h2>
    <div></div>
  </div>
  <div class="p-4 space-y-4">
    <div class="flex justify-between items-center p-4 bg-white/5 rounded-lg">
      <span class="text-white">Sound Effects</span>
      <button id="soundToggle" class="rounded-full bg-primary w-12 h-6 relative cursor-pointer transition-all duration-300" onclick="toggleSetting('sound')">
        <div id="soundToggleThumb" class="absolute top-0.5 left-0.5 bg-white w-5 h-5 rounded-full transition-all duration-300"></div>
      </button>
    </div>
    <div class="flex justify-between items-center p-4 bg-white/5 rounded-lg">
      <span class="text-white">Music</span>
      <button id="musicToggle" class="rounded-full bg-primary w-12 h-6 relative cursor-pointer transition-all duration-300" onclick="toggleSetting('music')">
        <div id="musicToggleThumb" class="absolute top-0.5 left-0.5 bg-white w-5 h-5 rounded-full transition-all duration-300"></div>
      </button>
    </div>
    <div class="flex justify-between items-center p-4 bg-white/5 rounded-lg">
      <span class="text-white">Notifications</span>
      <button id="notificationsToggle" class="rounded-full bg-white/20 w-12 h-6 relative cursor-pointer transition-all duration-300" onclick="toggleSetting('notifications')">
        <div id="notificationsToggleThumb" class="absolute top-0.5 right-0.5 bg-white w-5 h-5 rounded-full transition-all duration-300"></div>
      </button>
    </div>
  </div>
</div>

<!-- Community Screen -->
<div id="community" class="screen">
  <div class="flex items-center p-4 pb-2 justify-between">
    <div class="cursor-pointer" onclick="goToScreen('mainMenu')">
      <span class="material-symbols-outlined text-2xl">arrow_back</span>
    </div>
    <h2 class="text-white text-lg font-bold">Community</h2>
    <div></div>
  </div>
  <div class="p-4">
    <p class="text-white text-center mt-20">Connect with other players!</p>
    <p class="text-gray-400 text-center">Coming soon...</p>
  </div>
</div>

<!-- Quests Screen -->
<div id="quests" class="screen">
  <div class="flex items-center p-4 pb-2 justify-between">
    <div class="cursor-pointer" onclick="goToScreen('mainMenu')">
      <span class="material-symbols-outlined text-2xl">arrow_back</span>
    </div>
    <h2 class="text-white text-lg font-bold">Quests</h2>
    <div class="flex items-center gap-2">
      <span class="material-symbols-outlined text-yellow-400 text-xl">diamond</span>
      <span id="gemsDisplay" class="text-yellow-400 font-bold text-lg">0</span>
    </div>
  </div>
  <div class="p-4 space-y-3">
    <div class="text-center mb-4">
      <p class="text-gray-400 text-sm">New quests refresh every 5 minutes</p>
      <p id="questRefreshTimer" class="text-primary text-xs mt-1">Next refresh: --:--</p>
      <button onclick="refreshQuests()" class="mt-3 px-4 py-2 bg-primary text-white rounded-lg font-bold hover:bg-primary/90 transition-colors flex items-center gap-2 mx-auto">
        <span class="material-symbols-outlined text-lg">refresh</span>
        <span>Refresh Quests (200 Gold)</span>
      </button>
    </div>
    <div id="questList" class="space-y-3">
      <!-- Quests will be dynamically generated here -->
    </div>
  </div>
</div>

<!-- Rewards Screen -->
<div id="rewards" class="screen">
  <div class="flex items-center p-4 pb-2 justify-between">
    <div class="cursor-pointer" onclick="goToScreen('mainMenu')">
      <span class="material-symbols-outlined text-2xl">arrow_back</span>
    </div>
    <h2 class="text-white text-lg font-bold">Rewards</h2>
    <div></div>
  </div>
  <div class="p-4">
    <div class="p-4 bg-white/5 rounded-lg text-center mb-4">
      <span class="material-symbols-outlined text-6xl text-yellow-400">card_giftcard</span>
      <p class="text-white mt-2">Daily Reward</p>
      <p class="text-gray-400">Claim your earned gold!</p>
      <p class="text-yellow-400 font-bold mt-2" id="claimableGold">0 Gold Available</p>
    </div>
    <button id="claimRewardButton" class="w-full bg-primary text-background-dark py-3 rounded-lg font-bold" onclick="claimReward()">Claim Reward</button>
  </div>
</div>

<!-- Game Over Screen -->
<div id="gameOver" class="screen">
  <div class="flex flex-col items-center justify-center min-h-screen p-8">
    <div class="max-w-md w-full text-center space-y-6">
      <span class="material-symbols-outlined text-red-500 text-9xl">sentiment_dissatisfied</span>
      <h1 class="text-4xl font-bold text-white">Game Over</h1>
      <p class="text-gray-400">Your base was destroyed!</p>
      <div class="p-4 bg-white/5 rounded-lg">
        <p class="text-gray-300 text-sm mb-2">Wave Reached: <span id="gameOverWave" class="text-primary font-bold">1</span></p>
        <p class="text-gray-300 text-sm mb-2">Zombies Killed: <span id="gameOverKills" class="text-primary font-bold">0</span></p>
        <p class="text-gray-300 text-sm">Gold Earned: <span id="gameOverGold" class="text-yellow-400 font-bold">0</span></p>
      </div>
      <div class="space-y-3">
        <button class="w-full bg-primary text-background-dark py-3 rounded-lg font-bold" onclick="startGame()">
          Play Again
        </button>
        <button class="w-full bg-gray-600 text-white py-3 rounded-lg font-bold" onclick="goToScreen('mainMenu')">
          Main Menu
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Victory Screen -->
<div id="victory" class="screen">
  <div class="flex flex-col items-center justify-center min-h-screen p-8">
    <div class="max-w-md w-full text-center space-y-6">
      <span class="material-symbols-outlined text-yellow-400 text-9xl animate-bounce">emoji_events</span>
      <h1 class="text-4xl font-bold text-white">Victory!</h1>
      <p class="text-gray-400">You've successfully defended the base!</p>
      <div class="p-4 bg-white/5 rounded-lg">
        <p class="text-gray-300 text-sm mb-2">Level Completed: <span id="victoryLevel" class="text-primary font-bold">Whispering Woods</span></p>
        <p class="text-gray-300 text-sm mb-2">Waves Completed: <span id="victoryWaves" class="text-primary font-bold">20/20</span></p>
        <p class="text-gray-300 text-sm mb-2">Zombies Killed: <span id="victoryKills" class="text-primary font-bold">0</span></p>
        <p class="text-gray-300 text-sm mb-2">Towers Placed: <span id="victoryTowers" class="text-primary font-bold">0</span></p>
        <p class="text-gray-300 text-sm">Gold Earned: <span id="victoryGold" class="text-yellow-400 font-bold">0</span></p>
      </div>
      <div class="space-y-3">
        <button class="w-full bg-primary text-background-dark py-3 rounded-lg font-bold" onclick="goToScreen('levelSelection')">
          Next Level
        </button>
        <button class="w-full bg-gray-600 text-white py-3 rounded-lg font-bold" onclick="goToScreen('mainMenu')">
          Main Menu
        </button>
      </div>
    </div>
  </div>
</div>
</body>
</html>





